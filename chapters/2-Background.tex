\chapter{Background}
\label{ch2}
\Forf{T} relies on the research from many fields of study in both mathematics and computer science\ldots
\todoReword{Elaborate like a teasing summary}
%
%
%
%
%
\section{Basic Theory}\todoReword{theoretical foundation}
\subsection{Sets}
Cardinality

Union
%
\subsection{Geometry}
Interpolation

Circle Sectors
%
\subsection{Topology}
%
\subsubsection{Neighborhoods}
%\subsection{Adjacencies, Singularities and k-ring Neighborhoods}
Knowing the neighbors of a measuring point is the key to analyze our data. For regular data structures, e.g. 2D-images a pixel has four neighbors in orthogonal direction with a (relative) geometric distance of 1 and four further neighbors with a geometric distance of √2. Neglecting the geometric distance we can apply the same for vertices and faces and determine their neighbors using the orientation of the triangles:
• A face t j is adjacent to a face t i , when t j has an edge e m = {A m , B m }and t i has an edge e k = {B m , A m }.
• The vertices adjacent to a vertex p i are those p̊ i , belonging to the faces t̊ i ∶= {A i , B ≠i , C ≠i } ∨ {A ≠i , B i , C ≠i } ∨ {A ≠i , B ≠i , C i }.

Faces t̊ i and vertices p̊ i belong to the so-called 1-ring as they have distance of 1 within the graph of the mesh. The 1-ring can be extended to a 2-ring by using the verticesp̊ i as p i , which adds vertices and faces having a distance of 2 within the graph. This iterative concept can be repeated k times and the neighborhood is than referred to as k-ring. The distance within the graph can not be assumed equal to the geometric distance nor geodesic distance.

However it is used throughout literature as experiments are often done on synthetic data – especially in the field of Computer Graphics. Figure 2.6 shows the scheme of the 1-ring and an example for a 5-ring on a synthetic sphere in contrast to 5-rings on an acquired mesh. Even the triangles of the sphere are almost equal, we see that the outlines of the k-rings have a hexagonal shape, while geodesic ring would have the shape of a circle. Already the 1-rings of the acquired mesh have completely arbitrary shapes and sizes.

(a)(b)(c)(d)

Figure 2.6: k-ring neighborhood: (a) Scheme of a 1-ring neighborhood and 1 to 5-ring neighborhood for (b) a synthetic sphere and (c) for a wedge acquired using a 3D-scanner. The 1-ring shown in Figure 2.6a is closely related to the so-called triangle-fan used by Open Graphics Language (OpenGL). While the

Figure represents the most common case of an 1-ring equal to a triangle-fan as most parts of M 2 are organized like this. The second common case looks the same, with one or more adjacent faces missing – this is the case, when p̊ i is on the border of the mesh. However the data structure allows that non-adjacent faces are missing leading to singular vertices – not to be confused with solo vertices. 29 We can identify singular vertices connecting different parts of M 2 by determining one triangle-fan per vertex and compare them to the 1-ring neighborhood. The faces of the 1-ring are determined just by the presence of a shared central vertex [MB05] as shown before. Having the 1-ring we need to test if we can walk around the shared vertex using the faces and their neighbors.

This is shown in Figure 2.7a, where we can start at any of the vertices {B, . . . , G} following the directional edges between them. We than will arrive at vertex p G . If we have not started at p B , we will have to backtrack the edges in opposite direction as p A is a vertex on the border ∂M 2 . In the end we will have visited all vertices of the triangle fan {B, . . . , G}. When p A is not on the border, because a triangle {A, G, B} exists, we can visit all vertices without backtracking. Figure 2.7b shows the scheme for a border vertex, which is singular, because we can visit either the {B, C, D, E} or {F, G, H} of these two triangle-fans. Figure 2.7c shows an example from a 3D-model, where a non-border, singular vertex p A connects different parts of the mesh.

(a)(b)(C)

Figure 2.7: Schematic visualization of (a) a non-singular vertex p A with its triangle fan equaling its 1-ring neighborhood. When there is a triangle {A, G, B} the fan is closed – if not p A , p B and p G are vertices on the border of M 2 . (b) Singular vertex p A connecting two triangle fans. (c) Real world example for a singular vertex p A .~\cite[p.~29]{Mara12}
%
%
%
%
%
\section{\tdd}
\label{ch2s3}
\todoStyle{the 3 in \tdd{} looks too small}
The data upon which one convolves \forf{t} is called \tdd\todoCitation{\tdd{} name origin, BB82 from Mara12}. As described in Section~\ref{ch2s3ssM}, \tdd{} consists primarily of a single mesh $\bM$, which is the superset of $\bP$, a set of points, and the set $\bT$ consisting of triangular faces, each to be covered in Sections~\ref{ch2s3ssP} and~\ref{ch2s3ssF} respectively. \tdd{} also comes in two distinct flavors depending on its origin: acquired or synthetic, as discussed in Section~\ref{ch2s3ssAVS3}. The data can also include a texture map and other various types of information stored as scalar or vector fields, as elaborated on in~\ref{ch2s3ssFV}.
%
\subsection{Points}
\label{ch2s3ssP}
A point $\bp$ is the most primitive element of \tdd{}. "Point" is the abbreviated form of "measuring point", and is also known in other fields of study as a vertex, or a position vector $\in \mathbb{R}^3$\todoCitation{other names for a point}. A point is defined by the 3-dimensional Cartesian coordinates $x$, $y$ and $z$, and in \tdd{}, points are generally unique and not required to be in any particular order. In this thesis, a point is addressed using several different subscripts, depending on the context.

Index $v$ is the globally unique index, with which we can define the set\footnote{Please note that the indices in Equation~\ref{eq:defineSetOfPoints} begin with 1. This is significant because of the discordant conventions between addressing the first element of a data structure with 0 in programming languages such as C++ and python, versus addressing first elements with 1, as is the standard for mathematical literature. Because this thesis should indeed be considered mathematical literature, we will always start indices at 1, and only use index 0 for special cases. For example, $\bp_0$ is used to represent the defining center point of a one-ring neighborhood.}
\todoReword{add reference to neighborhoods section into footnote once it is created}
\begin{equation}
	\bP := \left \{\:\bp_v \mid v \in \mathbb{Z}^+, \;\text{and}\; 1\leq v \leq v_{max}\:\right \}
	\label{eq:defineSetOfPoints}
\end{equation}
where $v_{max}$ is the maximum index of points in the data, and is equivalent to the cardinality of the set of points $|\bP|$.%
\nomenclature[ab]{$\bP$}{the set of points $\bp$ in $\bM$}%
%\nomenclature[ac]{$\left |\bP\right |$}{the cardinality of $\bP$, equivalent to $v_{max}$}%
%\nomenclature[ad]{$\bp$}{a point}%
\nomenclature[ae]{$\bp_v$}{a specific point in $\bP$}%

Otherwise,
% when referencing to a point by its index within a specific one-ring neighborhood, we will use $\bp_k$, and %
 when referencing to a point within a particular face or neighborhood, the three corners can be referenced indirectly as $\bp_i$\footnote{or in the case of a nested loop: $\bp_k$, as seen in Algorithm~\ref{alg:serialBuildNeighborhoods}, and $\bp_j$, as seen in Algorithm~\ref{alg:serialCompute}}, $\bp_{\sipo}$, and $\bp_{\sipt}$, or directly as $\bp_0$, $\bp_1$, and $\bp_2$.%
\todoReword{ensure footnote indice remain correct}
%\nomenclature[af]{$\bp_k$}{a specific point in $\bN$}%
\nomenclature[ag]{$\bp_i$}{also $\bp_{\sipo}$, and $\bp_{\sipt}$; an indirectly referenced point within a particular face}%
%\nomenclature[ah]{$\bp_0$}{also $\bp_1$, and $\bp_2$; a directly referenced point within a particular face}~\cite[p.~25]{Mara12}%
%
\subsection{Faces}
\label{ch2s3ssF}
Faces are the another primitive element of \tdd{}. As we are working exclusively with triangular meshes~\cite[p.~26]{Mara12}, we define a face $\bt$ by the totally ordered~\cite{Weisstein19a} set of three distinct points, which we will index in clockwise order
%\footnote{It is worth mentioning here that many software packages, such as the GigaMesh Framework~\cite[p.~89]{Mara12}, may expect counter-clockwise ordering of indexes. \todoResearch{does the "right-hand-rule apply here?"} This is significant because the ordering provides an orientation by which visualization software can apply texture and/or lighting. The only mathematical significance of the ordering is the sign of the area of a face, and totally inconsequential when the absolute value is expected, as shown by\cite[p.~2]{Braden86}. This is yet another example of the difference between the conventions of mathematical literature versus those of computer science. And again, because this thesis should indeed be considered mathematical literature, we will continue to follow the conventions of mathematical literature.}
~\cite[p.~4]{Mara17}.

The triangular faces are addressed using the global index $k$, and each has three implicit edges whose descriptions are elaborated upon in Section~\ref{chBsEL}.
\begin{equation}
	\bt_k := \left \{\bp_0, \bp_1, \bp_2\right \} \equiv \left \{A_k, B_k, C_k\right \} \hspace{20pt}\text{abbreviated:}\hspace{20pt} \bt = \left \{A, B, C\right \}
	\label{eq:defineSetOfFaces}
\end{equation}%
\nomenclature[al]{$\bt_k$}{a specific face in $\bT$}%
%
\begin{figure}[ht]
\ffigbox
	{\includegraphics[width=0.8\linewidth]{example-image-16x9.png}}
	{\caption[A Triangular Face]{A triangular face showing points, edges, and orientation}\label{fig:facesOfAMesh}}
\end{figure}
%
The set of triangular faces is defined as
\begin{equation}
	\bT := \left \{\:\bt_k \mid k \in \mathbb{Z}^+, \;\text{and}\; 1\leq k \leq k_{max}\:\right \}
	\label{eq:defineSetOfFaces}
\end{equation}
where $k_{max}$ is the maximum index of faces in the data, and is equivalent to the cardinality of the set of faces $|\bT|$.%
\nomenclature[ai]{$\bT$}{the set of faces $\bt$ in $\bM$}%
%\nomenclature[aj]{$\left |\bT\right |$}{the cardinality of $\bT$, equivalent to $k_{max}$}%
%\nomenclature[ak]{$\bt$}{a face}%
%
\subsection{Edge Lengths}
\label{chBsEL}
While an edge is not typically\footnote{Other data structures, such as the Winged-Edge~\cite[p.~1]{Baumgart75}, may use edges as a primitive element} a primitive element of \tdd{}, but because edge lengths are of particular significance for both the design and implementation of \forf{t}, and as illustrated in Figure~\ref{fig:facesOfAMesh}, each triangular face is implicitly composed of three edges, we will endeavor to at least an edges length.

When in the context of a particular face $\bt_k$, we will use the single index $i$
\begin{equation}
	\xi_i := |\bp_{(\sipo)\%3} - \bp_{(\sipt)\%3}| \;:\; \forall i \in\{0,1,2\} \;\text{and}\; \bp_i \in \bt_k
	\label{eq:defineEdgeLengthFace}
\end{equation}%
\nomenclature[am]{$\xi_i$}{the length of edge $\xi_i$ of face $\bt_k$}%
\todoAsk{do I need $\forall$ here?}

and the double indices $v,k$, when an edge length is referenced in relation to particular point $\bp_v$
\begin{equation}
	\xi_{v,k} := |\bp_k - \bp_v|
	\label{eq:defineEdgeLengthPoint}
\end{equation}%
\nomenclature[an]{$\xi_{v,k}$}{the length of edge $\xi_i$ from point $\bp_v$}%
Please note the similar notation for the cardinality of a set $|\bP|$, to that for the length of the edge $|\xi_{v,k}|$ as defined in Equation~\ref{eq:defineEdgeLengthPoint}. While cardinality is simply the count of elements in the set, the length is calculated as the L2-norm of the referenced vector.~\cite[p.~26]{Mara12}
%\begin{align}
\begin{equation}
\begin{aligned}
	|\bp_k - \bp_v| & = \lVert\bp_k - \bp_v\rVert_2 \\
					& = \sqrt{(x_k-x_v)^2 + (y_k-y_v)^2 + (y_k-y_v)^2}
	\label{eq:defineEdgeLengthCalc}
\end{aligned}
\end{equation}
%\end{align}
\todoResearch{can I avoid sqrt altogether by performing entire algorithm squared?}
%
\subsection{Meshes}
\label{ch2s3ssM}
In \tdd{}, a mesh $\bM$ is the digital representation of a discrete manifold embedded in $\mathbb{R}^3$, and is typically\footnote{except in the case of specifically designed synthetic data~\ref{Experiments}} 2D-non-planar\todoStyle{in 2D, the 2 looks small} and comprised of non-regular, triangular faces composed of connected points.~\cite[p.~25]{Mara12} A mesh is the superset defined as
\begin{equation}
	\bM := \left \{\bP,\:\bT\right \}
	\label{eq:defineMesh}
\end{equation}%
\nomenclature[aa]{$\bM$}{a mesh; the superset including the sets of all points $\bp$ and faces $\bt$}%
with the set $\bP$ consisting of points, and the set $\bT$ consisting of triangular faces.

Many 3D-scanners produce point clouds\todoCitation{}{}, which as the name suggests, are comprised soley of a set of points $\bP$ and do not provide a set of triangular faces $\bT$. However, it is possible, and necessary for the production of a mesh, to perform a point set triangulation\todoCitation{}{} in order to connect $\bP$ into a set of triangle faces $\bT$, enabling one to combine the two sets into a mesh~\cite[p.~26]{Mara12}. For example, during our experiments, we perform the well-known Delaunay triangulation\todoCitation{} in order to produce a mesh from a randomly generated point cloud\todoReword{add ref to experiments}.
%
\subsection{Acquired vs Synthetic \tdd{}}
\label{ch2s3ssAVS3}
The corpus of \tdd{} exists in two flavors, acquired and synthetic data, with each handily classifiable by the fashion in which it was generated, and the characteristics innate to those techniques.

Acquired \tdd{} is typically captured as a point cloud utilizing various methods, such as: Time-of-Flight, Structured Light, or Structure from Motion~\cite[p.~19]{Mara12}, then exported as a triangle mesh, often consisting upwards of a million points and up to twice as many faces\footnote{TODO: reference the interesting experimental finding about face to vertex ratio}, from software packages accompanying the 3D-scanners. These exported meshes ~\cite[p.~25]{Mara12} uniformly contain noise and may exhibit other complexities for analysis, such as: non-manifold points, multiple borders or holes in the surface, inverted face orientation, non-manifold edges, and agglutination or degenerate faces. ~\cite[p.~28-32]{Mara12}
\todoResearch{Address how does the filter handles edges and unclean meshes, comeback after equations written for new algorithm}

Conversely, synthetic \tdd{} is artfully crafted to obey the constraints of being a good mesh\todoReword{define a good mesh here}, without the complexities exhibited by acquired data. When modeling 3-dimensional objects, synthetic \tdd{} can require significantly less memory for storage, as simplifications can made for large regular surfaces. For example, even the largest rectangular surface can be modeled with only four points and two faces, whereas the acquired data methods require that the Nyquist–Shannon sampling theorem\todoCitation{Nyquist Shannon Theorem} be obeyed for the smallest detectable feature throughout the entire surface.

For our experiments, we created another kind synthetic \tdd{} which does not model an object. Instead, our new synthetic mesh generators\todoReword{reference experiments} produce four different types of tessellations on arbitrarily large planar surfaces.
%
\subsection{Function Values}
\label{ch2s3ssFV}
In addition to the 3 Cartesian coordinates, a point may often contain other relevant data in the form of scalar fields, or when taken together, vector fields. This information, which is stored at each point $\bp$, can include data regarding: RGB color, material type, reflectivity, transparency, quality, confidence, or the resulting function values from an analytical filter such as the Multi-Scale Integral Invariants (MSII) filter~\cite[p.~21]{Mara12}.

\forf{T} is agnostic to the meaning of information represented by the data, therefore, it can similarly process any such function values stored as a scalar field. However, because the filter was designed to only convolve scalar fields, any multi-dimensional data, such as RGB color, must be processed individually as independent scalar fields. The result is that we can define a scalar field simply as a set of function values.
%
\begin{equation}
	\bF := \left \{\: f_v \mid v \in \mathbb{Z}^+, \;\text{and}\; 1\leq v \leq|\bP| \:\right \}
	\label{eq:defineSetOfFunctionValues}
\end{equation}%
\nomenclature[ap]{$\bF$}{a scalar field; the set of function values $f_v$}%
\nomenclature[aq]{$|\bF|$}{the cardinality of $\bF$, $\equiv |\bP|$}%
\nomenclature[ar]{$f$}{a function value}%
\nomenclature[as]{$f_v$}{a specific function value in $\bF$, corresponding to $\bp_v$}%
%
This definition shares the index $v$ with the definition for a set of points and uses $|\bP|$ instead of $|\bF|$ as the maximum iteration value, in order to highlight the fact that indeed $|\bF| \mbeq |\bP|$, because function values are stored 1-for-1 with points in \tdd{}.
%
%
%
%
%
\section{Architectures of Concurrency}
%
\subsection{Serial Computation \& Threads}
thread can be identified using a one-dimensional, two-dimensional, or three-
dimensional thread index, forming a one-dimensional, two-dimensional, or three-
dimensional block of thread, called a thread block. This provides a natural way
to invoke computation across the elements in a domain such as a vector, matrix,
or volume. However, a kernel can be executed by multiple equally-shaped thread
blocks, so that the total number of thread is equal to the number of thread
per block times the number of blocks. thread blocks are required to execute
independently: It must be possible to execute them in any order, in parallel or
in series. This independence requirement allows thread blocks to be scheduled
in any order across any number of cores as illustrated by Figure 5, enabling
programmers to write code that scales with the number of cores. [7, p. 2.2]
\todoReword{found elsewhere in thesis}
%
\subsection{Multi-threaded Computation}
Processors through Supercomputers and Data Centers
%
\subsection{Concurrency vs Parallelism}
%
\subsection{Flynn's taxonomy}
1.1	Single instruction stream single data stream (SISD)
1.2	Single instruction stream, multiple data streams (SIMD)
1.3	Multiple instruction streams, single data stream (MISD)
1.4	Multiple instruction streams, multiple data streams (MIMD)
%
\section{CUDA: An interface for GPGPU implementation}
\subsection{CUDA C Runtime}%3.2. CUDA C Runtime}
\subsubsection{Explicit Synchronization}%3.2.5.5.3. Explicit Synchronization}
\subsection{Versioning and Compatibility}%3.3. Versioning and Compatibility}
\subsection{Hardware Implementation}%4. Hardware Implementation}
\subsubsection{SIMT Architecture}%4.1. SIMT Architecture}
\subsection{Host Memory and Device Memory}
\subsection{Versions <9, vs >= 9}
%
%
%
%
%
\section{Evaluation and Analysis of Concurrent Algorithms}~\cite[p.~330]{Lang17}
Multi-node out of scope?!
%
\subsection{Timing}
%\begin{equation}
	N = input size (num. ops)
	P = processor count
	Ts(N) = Sequential execution time
	Tbest(N) = Optimal execution time
	TP(N, P) = Parallel runtime
%\end{equation}
%
\subsection{Speedup, efficiency}
	Speedup:
S(N, P) = Tbest(N)/TP(N, P)

	Efficiency:
E(N, P) = Tbest (N)/PTP(N, P) = S/P

	Costs:
C(N, P) = PTP(N, P)
%
\subsection{Degree of Parallelism}
	0 < q < 1 is the sequential part
	1-q = is the parallelizable part
%
\subsection{Iso-efficiency}
	WK(P) = iso-efficient if it fulfills:
	TO(WK(P), P) = KWK(P)~\cite[p.~350]{Lang17}
%
\subsection{Scalability}
	A parallel system is called scalable only if in has an iso-efficency function
%
%
%
%
%
\section{Summary}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi tincidunt eget
ipsum eu iaculis. Cras vel sem eu velit eleifend porta vel sit amet massa. Etiam
a posuere nunc. Aenean aliquam viverra dapibus. Aliquam ac eros a purus feugiat
rhoncus. Donec faucibus ut nibh ut cursus. Aliquam erat volutpat. Proin efficitur
nulla sit amet iaculis condimentum. Cras placerat leo vitae venenatis feugiat. In
hac habitasse platea dictumst. Orci varius natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. In aliquet sagittis dui eu pulvinar.
Morbi a arcu eu dolor sagittis varius. Aliquam dignissim tortor sed tortor
suscipit, eget imperdiet mauris convallis.
