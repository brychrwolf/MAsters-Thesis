\chapter{Profiling \& Exploiting Concurrency}
\label{ch5}
In the previous chapter we presented an improved version of \Forf{t} as it is currently implemented within the GigaMesh framework, and while it has improved accuracy, it is entirely serial in design, so that unfortunately, its performance suffers greatly under the complexity of modern mesh sizes, which with the current high resolution scanners in use, can grow to be MESH\_SIZES\todoResearch{mesh sizes}. We will now explore this as-yet-unpublished algorithm in order to discover any instances of any concurrency and opportunities worthy to exploit in order to improve its performance.

%
%
%
%
\section{Serial Implementation}
\label{ch5sSI}
In this section, we now combine all of the equations from the previous chapter,~\ref{eq:localMinimumEdgeLength} through~\ref{eq:meanFuncValAtPv}, into a three-part algorithm using mathematical pseudo-code, with the goal of facilitating the implementation of the improved version of \forf{t}. However, before one is able to begin convolving the filter, the computations require that the one-ring neighborhoods already be known. Then during the convolutions, the filter uses all edge lengths at least once per iteration, and twice for non-border edge lengths, which are shared between adjacent neighborhoods. Therefore, it is beneficial to split the algorithm into three distinct parts, then save the results of the first two parts to be used during the iterative convolutions of the third part, with the result being a massive increase in efficiency by greatly reducing the number of operations-per-iteration required.
\todoBackground{add convolution and convolve to background}
\todoBackground{memory vs speed cost compromise}

%
%
%
\subsection{Discovering Neighborhoods}
\label{ch5sSIssDN}
Initially, one must discover all the points $\bp_i$ which comprise each neighborhood $\bN_v$ in the entire mesh $\bM$, which is the purpose of Algorithm~\ref{alg:serialBuildNeighborhoods}. Although building this family of sets outside of the principle loop adds an additional $2\cdot |\bT|^3$ operations in total, doing so enables Alogrithm~\ref{alg:serialCalculateEdgeLengths} to exploit this family of sets to vastly reduce its complexity from $|\bP|^{|\bT|}$ to approximately\footnote{depending on the average size of all neighborhoods, assumed here to be about 6}\todoResearch{find good average for average neighborhood size} $|\bP|^6$. Also, as we will see in Algorithm~\ref{alg:serialCompute}, when $\tau$ is the chosen number of iterations to perform, the complexity of the main procedure can be significantly reduced\todoReword{can be significantly reduced} to only $\tau^{|\bP|^{6*3}}$, down from the $\tau^{|\bP|^{|\bF|*3}}$ that would have been necessary had the neighborhoods not already been discovered and the procedure been otherwise required to discover the members of $\bN_v$ in each iteration.%
\nomenclature[]{$\tau$}{the chosen number of iterations to perform}%
\todoBackground{family of sets}
\todoBackground{complexity, big O notation}

\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\Input{the set of all triangular faces $\bT$}
	\Output{the family of sets of discovered neighborhoods $\bN$}

	\bigskip
	\FuncSty{serialBuildNeighborhoods}\FuncArgSty{($\bT$)}\;
\nl	\For{$\bt \in \bT$}{
\nl		\For{$\bp_a \in \bt$}{
			\linespread{1.5}\selectfont
\nl				$\bN_v \leftarrow \bN_v \cup \left \{ \bp_b, \bp_c \right \}$\;
		}
	}
	\caption{Serial algorithm for building the family of sets of all discovered members of each neighborhood in the mesh}
\end{algorithm}%
\nomenclature[ga]{$\widehat{\bp_i}$}{the unique index for point $\bp_i$, corresponding to $v \in \bM$}%
\todoReword{Is $\widehat{\bp_i}$ required?}
\todoReword{nomencalture $\bN$ is a family of sets}
\todoAsk{must I say for all points in a face, or is this enough}

%Algorithm~\ref{alg:serialBuildNeighborhoods} uses the symbol $\widehat{\bp_i}$ represents the unique index for point $\bp_i$, corresponding to $v \in \bM$, so that we can discover the neighborhood $\bN_{\widehat{\bp_i}}$ by performing a union operation with the set of neighboring points whose indices change incrementally with $i$ in order to always represent the two neighbors of $\bp_i \in f$.

%
%
%
\subsection{Calculate Edge Lengths}
\label{ch5sSIssCEL}
In the next step, Algorithm~\ref{alg:serialCalculateEdgeLengths} calculates all the distinct edge lengths $\ell_{v,i}$ which are present in the mesh $\bM$, as well as the global minimum edge length $\gelm$.

As shown in Equation~\ref{eq:defineEdgeLengthPoint}, the calculation of an edge's length requires taking the L2-norm of the difference between the two points, which involves using the square root operation. In modern software, the square root operation is performed by computing multiple iterations of the so-called, recurrence equation, using Newton's method\todoCitation{}{software uses Newton's iteration for sqrt}. This procedure is otherwise known as "Newton's Iteration." ~\cite{Weisstein19b} The impact for \forf{t} is that the computation of a square root typically\todoCitation{}{how slow is Newton's iteration compared to others} takes many more compute cycles than other operations, and thus takes more time to complete. In fact, because of the slowness of the square root operation, computing the L2-norm in order to calculate an edge's length is empirically the most costly operation performed by the filter\todoResearch{qualify, do experiment to prove how slow sqrt is}. Therefore, it is imperative that we pay special attention to avoid unnecessary calls to calculate an edge's length. For that reason, we have defined the symbol $\ellstar$ to represent the calculation of an edge's length using "Newton's Iteration", so as to draw focus to its importance while designing an efficient implementation of \forf{t}.
\todoRewrite{consider parts of this for a footnote}

Although building this set outside of the principle loop requires ${\ellstar}^{(v^k)}$ operations, where $\ellstar$ is the most costly operation in the entire algorithm\todoCitation{calculating $\ellstar$ is expensive}, it would be otherwise impossible to calculate the globally shortest edge length $\gelm$. However, if we also store the results of each edge length, doing so enables the main procedure to completely exclude all $\ellstar$ operations from the principle loop, and as we will see in Algorithm~\ref{alg:serialCompute}, that reduces the total count of $\ellstar$ operations which must be performed from

${(2\,\xi_{border} + 4\,\xi_{non-border})\cdot\tau^v}$ down to only the initial $1\cdot v^k$, becoming completely independent of $\tau$ and significantly less than had the procedure been required to calculate an edge length each time it was used during computation.%
\nomenclature[gb]{$\ellstar$}{the procedure of calculating an edge's length using ``Newton's Iteration'', the most costly operation in the Fast One-Ring filter, due to use of $\sqrt{(\cdot)}$}%

\todoReword{mention memory costs}%
\todoBackground{add $\ellstar$}%
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\Input{the set of all points $\bP$, the family of sets of discovered neighborhoods $\bN$}
	\Output{new function values}

	\bigskip
	\FuncSty{CalculateEdgeLengths}\FuncArgSty{($\bP$,\,$\bN$)}\;
\nl	\For{$\bp_v \in \bP$}{
\nl		\For{$\bp_i \in \bN_v$}{
			\linespread{1.5}\selectfont
\nl			$\ell_{v,i} \leftarrow |\bp_i - \bp_v|$\label{precal-bpkbpv}\tcc*[r]{$\ellstar$ every edge length}
\nl			$\gelm \leftarrow \min\left \{\gelm,\,\ell_{v,i}\right \}$\tcc*[r]{Eq:~\ref{eq:globalMinimumEdgeLength}}
		}
	}
	\caption{Serial algorithm for the calculations required by the Fast One-Ring smoothing filter\label{alg:serialCalculateEdgeLengths}}
\end{algorithm}
\todoStyle{subscript v,i looks bad, change kerning}
% If alg.1 changes, update reference to number of new symbols.

Algorithm~\ref{alg:serialCalculateEdgeLengths} introduces five new symbols: $v$ is used to represent a unique index for each vertex in $\bM$; $k$ indexes each neighboring point in the one-ring neighborhood $\bN_v$; whose cardinality is $n_v$, $|\bp_k-\bp_v|$ from line~\ref{precal-bpkbpv} is analogous to $|\bp_i-\bp_0|$ from Equation~\ref{eq:localMinimumEdgeLength} when $\bp_v$ becomes $\bp_0$; and lastly, $\ell_{vk}$ is the length of the edge between $\bp_v$ and $\bp_k$.%
\todoReword{combine all $\xi \eta \delta$, all represent aan edge length}
%
\subsection{Computation}
In the third and final part, Algorithm~\ref{alg:serialCompute}, we illustrate the remaining steps required to convolve the Fast One-Ring smoothing filter, after having completed the pre-calculations in Algorithms~\ref{alg:serialBuildNeighborhoods} and~\ref{alg:serialCalculateEdgeLengths}. For a user-defined number of iterations $\tau$, one must iterate over each member of the neighborhood $\bp_i \in \bN_v, \forall v \in \bM$.


\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\linespread{1}\selectfont
	\FuncSty{Calculate}\FuncArgSty{(a,b)}\;
	\nl\For{$\tau\leftarrow 1\;\KwTo\;\#iterations$}{
	\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
	\nl		\For{$i \leftarrow 1\:\KwTo\:n_v$}{
				\linespread{2}\selectfont
	\nl			$\alpha_i \leftarrow$ \begin{large}
					$\text{cos}^{-1}\Big(\frac{
						(\ell_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})^2 +
						(\ell_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})^2 -
						(\ell_{\widehat{\bp_{\sipo}},\widehat{\bp_{\sipt}}})^2
					}{2
						(\ell_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})
						(\ell_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})
					}\Big)$\tcc*[r]{Eq:~\ref{eq:alphaFromEdgeLengths}}
				\end{large}
				\linespread{1.5}\selectfont
	\nl			$\beta_i \leftarrow (\pi - \alpha_i)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:betaFromHalfAlpha}}
	\nl			\kern-2pt$A_i \leftarrow \gelm^2\alpha_i\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:circularSectorArea}}
	\nl			\kern-7pt$\Dc_i \leftarrow \big(2\:\gelm\:\sin(\alpha_i\mathbin{/}2)\big)\mathbin{/}(3\alpha_i\mathbin{/}2)$\tcc*[r]{Eq:~\ref{eq:distToCoG}}
	\nl			\kern1pt$\zeta_i \leftarrow \gelm\mathbin{/}\sin(\beta_i)$\tcc*[r]{Eq:~\ref{eq:zeta}}
	\nl			\For{$j \in {1,2}$}{
	\nl				\kern-8pt$\Dz_j \leftarrow \zeta_i\mathbin{/}|\bp_0 - \bp_j|$\tcc*[r]{Eq:~\ref{eq:distanceIForInterpolation},~\ref{eq:distanceIp1ForInterpolation}}
	\nl				$f'_j \leftarrow f_0(1 - \Dz_j) + f_j\Dz_j$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0},~\ref{eq:interpolatedFip1}}
				}
	\nl			$f^\bs_i \leftarrow f_0(1 - \Dc_i) + \big((f_1 + f_2)\Dc_i\big)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:weightedMeanAtCoGatSector}}
	\nl			\kern-2pt$\tilde{A}_v \leftarrow \tilde{A}_v + A_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
	\nl			$\tilde{f}_v \leftarrow \tilde{f}_v + A_if^{\bs}_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
			}

	\nl		$\bar{f}_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
		}
	}
	\caption{Serial algorithm for the Fast One-Ring smoothing filter for scalar fields on discrete manifolds\label{alg:serialCompute}}
\end{algorithm}%
%
\section{Data Partitioning}%~\cite[p.~357]{Lang17}
%Data Partitioning is important.
%
\section[Acceleration by GPGPU]{Acceleration by General-purpose
computing on Graphics Processing Units (GPGPU)}
%
%
\section{Summary}
%then calculate all the edge lengths $\ell_{vk}$, as well as the global minimum edge length $\gelm$. Afterwards, one may efficiently convolve the filter, for as many number of iterations as required to achieve the desired smoothing effect.

