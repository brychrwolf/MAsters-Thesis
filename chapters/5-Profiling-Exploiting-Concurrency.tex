\chapter{Profiling \& Exploiting Concurrency}
\label{ch5}
In the previous chapter we presented an improved version of \Forf{t} as it is currently implemented within the GigaMesh framework, and while it has improved accuracy, it is entirely serial in design, so that unfortunately, its performance suffers greatly under the complexity of modern mesh sizes, which with the current high resolution scanners in use, can grow to be MESH\_SIZES\todoResearch{mesh sizes}. We will now explore this as-yet-unpublished algorithm in order to discover any instances of any concurrency and opportunities worthy to exploit in order to improve its performance.

%
%
%
%
\section{Serial Implementation}
\label{ch5sSI}
In this section, we now combine all of the equations from the previous chapter,~\ref{eq:localMinimumEdgeLength} through~\ref{eq:meanFuncValAtPv}, into three-part algorithm using mathematical pseudo-code, with the goal of facilitating the implementation of the improved version of \forf{t}. In order to begin convolving the filter, the computations require that the one-ring neighborhoods already be known. Then during the convolutions, the filter uses all edge lengths at least once per iteration, and twice for non-border edge lengths, which are shared between adjacent neighborhoods. Therefore, it is beneficial to split the algorithm into three distinct parts, then save the results of the first two parts to be used during the iterative convolutions of the third part, with the result being a massive increase in efficiency by greatly reducing the number of calculations-per-iteration required.
\todoBackground{add convolution and convolve to background}

%
%
%
\subsection{Discovering Neighborhoods}
\label{ch5sSIssDN}
Initially, one must discover all the points $\bp_i$ which comprise each neighborhood $\bN_v$ in the entire mesh $\bM$, which is the purpose of Algorithm~\ref{alg:serialBuildNeighborhoods}. Although building this family of sets outside of the principle loop, adds an additional $2\cdot |\bF|^3$ operations, as we will see in Algorithm~\ref{alg:serialCompute}, doing so enables the main procedure to significantly decrease one factor of the required operations-per-iteration to only $\tau^{(v^k)}$, where $\tau$ is the chosen number of iterations to perform, down from the $\tau^{(v^{|\mathcal{F}|})}$ that would have been otherwise necessary had the procedure been required to discover the members of $\bN_v$ in each iteration.%
\nomenclature[]{$\tau$}{the chosen number of iterations to perform}%
\todoBackground{family of sets}

\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\FuncSty{serialBuildNeighborhoods}\FuncArgSty{(a,b)}\;
\nl	\For{$\bt \in \bT$}{
\nl		\For{$\bp_a \in \bt$}{
			\linespread{1.5}\selectfont
\nl				$\bN_v \leftarrow \bN_v \cup \left \{ \bp_b, \bp_c \right \}$\;
		}
	}
	\caption{Serial algorithm for discovering and building the family of sets of the neighborhoods required by \forf{t} \label{alg:serialBuildNeighborhoods}}
\end{algorithm}%
\nomenclature[ga]{$\widehat{\bp_i}$}{the unique index for point $\bp_i$, correspondign to $v \in \bM$}

%Algorithm~\ref{alg:serialBuildNeighborhoods} uses 
The symbol $\widehat{\bp_i}$ represents the unique index for point $\bp_i$, corresponding to $v \in \bM$.
\todoReword{is phat needed?}
%, so that we can discover the neighborhood $\bN_{\widehat{\bp_i}}$ by performing a union operation with the set of neighboring points whose indices change incrementally with $i$ in order to always represent the two neighbors of $\bp_i \in f$.

%
%
%
\subsection{Calculate Edge Lengths}
\label{ch5sSIssCEL}
In the second part, Algorithm~\ref{alg:serialCalculateEdgeLengths}, we calculate the edge lengths $\eta_{vk} \; \forall v \in \bM, \; \forall  k \in \bN_v$, as well as the global minimum edge length $\gelm$. Although building this set outside of the principle loop requires ${\els}^{(v^k)}$ operations, where $\els$ is the most costly operation in the entire algorithm\todoCitation{calculating $\els$ is expensive}, as we will see in Algorithm~\ref{alg:serialCompute}, doing so enables the main procedure to completly exclude all $\els$ operations from the principle loop, reducing the total amount of times which $\els$ must be performed from ${(2\,\xi_{border} + 4\,\xi_{non-border})\cdot\tau^v}$ down to only the initial $1\cdot v^k$, which is completely independant of $\tau$ and significantly less than had the procedure been required to calculate an edge length each time it was used during computation.%
\nomenclature[gb]{$\els$}{the procedure of calculating an edge's length using \"Newton's Iteration\", the most costly operation in the Fast One-Ring filter, due to use of $\sqrt{(\cdot)}$}%

In modern software, the square root operation is performed by computing multiple iterations of the so-called, recurrence equation, using Newton's method\todoCitation{}{software uses Newton's iteration for sqrt}. This procedure is otherwise known as "Newton's Iteration." ~\cite{Weisstein19b} The impact for \forf{t} is that the computation of a square root typically\todoCitation{}{how slow is Newton's iteration compared to others} takes many more compute cycles than other operations, and thus takes more time to complete. In fact, because of the slowness of the square root operation, computing the L2-norm in order to calculate an edge's length is empirically the most costly operation performed by the filter\todoResearch{qualify, do experiment to prove how slow sqrt is}. Therefore, it is imperative that we take special attention to avoid unnecessary calls to calculate an edge's length, thus we have defined the symbol $\els$ to represent the calculation of an edge's length using "Newton's Iteration", in order to draw focus to its importance \todoReword{facilitate that attention} in designing an efficient implementation of \forf{t}.%

\todoReword{mention memory costs}%
\todoBackground{add $\els$}%
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\FuncSty{CalculateEdgeLengths}\FuncArgSty{(a,b)}\;
\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
\nl		\For{$k\leftarrow 1\;\KwTo\;n_v$}{
			\linespread{1.5}\selectfont
\nl			$\eta_{vk} \leftarrow |\bp_k - \bp_v|$\label{precal-bpkbpv}\tcc*[r]{$\els$ every edge length}
\nl			$\gelm \leftarrow \min\left \{\gelm, \eta_{vk}\right \}$\tcc*[r]{Eq:~\ref{eq:globalMinimumEdgeLength}}
		}
	}
	\caption{Serial algorithm for the calculations required by the Fast One-Ring smoothing filter\label{alg:serialCalculateEdgeLengths}}
\end{algorithm}
% If alg.1 changes, update refence to number of new symbols.

Algorithm~\ref{alg:serialCalculateEdgeLengths} introduces five new symbols: $v$ is used to represent a unique index for each vertex in $\bM$; $k$ indexes each neighboring point in the one-ring neighborhood $\bN_v$; whose cardinality is $n_v$, $|\bp_k-\bp_v|$ from line~\ref{precal-bpkbpv} is analogous to $|\bp_i-\bp_0|$ from Equation~\ref{eq:localMinimumEdgeLength} when $\bp_v$ becomes $\bp_0$; and lastly, $\eta_{vk}$ is the length of the edge between $\bp_v$ and $\bp_k$.%
\todoReword{combine all $\xi \eta \delta$, all represent aan edge length}
%
\subsection{Computation}
In the third and final part, Algorithm~\ref{alg:serialCompute}, we illustrate the remaining steps required to convolve the Fast One-Ring smoothing filter, after having completed the pre-calculations in Algorithms~\ref{alg:serialBuildNeighborhoods} and~\ref{alg:serialCalculateEdgeLengths}. For a user-defined number of iterations $\tau$, one must iterate over each member of the neighborhood $\bp_i \in \bN_v, \forall v \in \bM$.


\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\linespread{1}\selectfont
	\FuncSty{Calculate}\FuncArgSty{(a,b)}\;
	\nl\For{$\tau\leftarrow 1\;\KwTo\;\#iterations$}{
	\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
	\nl		\For{$i \leftarrow 1\:\KwTo\:n_v$}{
				\linespread{2}\selectfont
	\nl			$\alpha_i \leftarrow$ \begin{large}
					$\text{cos}^{-1}\Big(\frac{
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})^2 +
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})^2 -
						(\eta_{\widehat{\bp_{\sipo}},\widehat{\bp_{\sipt}}})^2
					}{2
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})
					}\Big)$\tcc*[r]{Eq:~\ref{eq:alphaFromEdgeLengths}}
				\end{large}
				\linespread{1.5}\selectfont
	\nl			$\beta_i \leftarrow (\pi - \alpha_i)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:betaFromHalfAlpha}}
	\nl			\kern-2pt$A_i \leftarrow \gelm^2\alpha_i\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:circularSectorArea}}
	\nl			\kern-7pt$\Dc_i \leftarrow \big(2\:\gelm\:\sin(\alpha_i\mathbin{/}2)\big)\mathbin{/}(3\alpha_i\mathbin{/}2)$\tcc*[r]{Eq:~\ref{eq:distToCoG}}
	\nl			\kern1pt$\zeta_i \leftarrow \gelm\mathbin{/}\sin(\beta_i)$\tcc*[r]{Eq:~\ref{eq:zeta}}
	\nl			\For{$j \in {1,2}$}{
	\nl				\kern-8pt$\Dz_j \leftarrow \zeta_i\mathbin{/}|\bp_0 - \bp_j|$\tcc*[r]{Eq:~\ref{eq:distanceIForInterpolation},~\ref{eq:distanceIp1ForInterpolation}}
	\nl				$f'_j \leftarrow f_0(1 - \Dz_j) + f_j\Dz_j$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0},~\ref{eq:interpolatedFip1}}
				}
	\nl			$f^\bs_i \leftarrow f_0(1 - \Dc_i) + \big((f_1 + f_2)\Dc_i\big)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:weightedMeanAtCoGatSector}}
	\nl			\kern-2pt$\tilde{A}_v \leftarrow \tilde{A}_v + A_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
	\nl			$\tilde{f}_v \leftarrow \tilde{f}_v + A_if^{\bs}_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
			}

	\nl		$\bar{f}_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
		}
	}
	\caption{Serial algorithm for the Fast One-Ring smoothing filter for scalar fields on discrete manifolds\label{alg:serialCompute}}
\end{algorithm}%
%
\section{Data Partitioning}%~\cite[p.~357]{Lang17}
%Data Partitioning is important.
%
\section[Acceleration by GPGPU]{Acceleration by General-purpose
computing on Graphics Processing Units (GPGPU)}
%
%
\section{Summary}
%then calculate all the edge lengths $\eta_{vk}$, as well as the global minimum edge length $\gelm$. Afterwards, one may efficiently convolve the filter, for as many number of iterations as required to achieve the desired smoothing effect.

