\chapter{Profiling \& Exploiting Concurrency}
\label{ch5}
In the previous chapter we presented an improved version of \Forf{t} as it is currently implemented within the GigaMesh framework, and while it has improved accuracy, it is entirely serial in design, so that unfortunately, its performance suffers greatly under the complexity of modern mesh sizes, which with the current high resolution scanners in use, can grow to be MESH\_SIZES\todoResearch{mesh sizes}. We will now explore this as-yet-unpublished algorithm in order to discover any instances of any concurrency and opportunities worthy to exploit in order to improve its performance.

%
%
%
%
\section{Serial Implementation}
\label{ch5sSI}
In this section, we now combine all of the equations from the previous chapter,~\ref{eq:localMinimumEdgeLength} through~\ref{eq:meanFuncValAtPv}, into a three-part algorithm using mathematical pseudo-code, with the goal of facilitating the implementation of the improved version of \forf{t}. However, before one is able to begin convolving the filter, the computations require that the one-ring neighborhoods already be known. Then during the convolutions, the filter uses all edge lengths at least once per iteration, and twice for non-border edge lengths, which are shared between adjacent neighborhoods. Therefore, it is beneficial to split the algorithm into three distinct parts, then save the results of the first two parts to be used during the iterative convolutions of the third part, with the result being a massive increase in efficiency by greatly reducing the number of operations-per-iteration required.
\todoBackground{add convolution and convolve to background}
\todoBackground{memory vs speed cost compromise}

%
%
%
\subsection{Discovering Neighborhoods}
\label{ch5sSIssDN}
Initially, one must discover all the points $\bp_i$ which comprise each neighborhood $\bN_v$ in the entire mesh $\bM$, which is the purpose of Algorithm~\ref{alg:serialBuildNeighborhoods}. Although building this family of sets outside of the principle loop adds an additional $2\cdot |\bT|^3$ operations in total, doing so enables Alogrithm~\ref{alg:serialCalculateEdgeLengths} to exploit this family of sets to vastly reduce its complexity from $|\bP|^{|\bT|}$ to approximately\footnote{depending on the average size of all neighborhoods, assumed here to be about 6}\todoResearch{find good average for average neighborhood size} $|\bP|^6$. Also, as we will see in Algorithm~\ref{alg:serialConvolveFilter}, when $\tau$ is the chosen number of iterations to perform, the complexity of the main procedure can be significantly reduced\todoReword{can be significantly reduced} to only $\tau^{|\bP|^{6*3}}$, down from the $\tau^{|\bP|^{(|\bF|*3)}}$ that would have been necessary had the neighborhoods not already been discovered and the procedure been otherwise required to discover the members of $\bN_v$ in each iteration.%
\nomenclature[]{$\tau$}{the chosen number of iterations to perform}%
\todoBackground{family of sets}
\todoBackground{complexity, big O notation}

\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\Input{the set of all triangular faces $\bT$}
	\Output{the family of sets of discovered neighborhoods $\bN$}

	\bigskip
	\FuncSty{serialBuildNeighborhoods}\FuncArgSty{($\bT$)}\;
\nl	\For{$\bt \in \bT$}{
\nl		\For{$\bp_a \in \bt$}{
			\linespread{1.5}\selectfont
\nl				$\bN_v \leftarrow \bN_v \cup \left \{ \bp_b, \bp_c \right \}$\;
		}
	}
	\caption{Serial algorithm for building the family of sets of all discovered members of each neighborhood in the mesh\label{alg:serialBuildNeighborhoods}}
\end{algorithm}%
\nomenclature[ga]{$\widehat{\bp_i}$}{the unique index for point $\bp_i$, corresponding to $v \in \bM$}%
\todoReword{Is $\widehat{\bp_i}$ required?}
\todoReword{nomencalture $\bN$ is a family of sets}
\todoAsk{must I say for all points in a face, or is this enough}

%Algorithm~\ref{alg:serialBuildNeighborhoods} uses the symbol $\widehat{\bp_i}$ represents the unique index for point $\bp_i$, corresponding to $v \in \bM$, so that we can discover the neighborhood $\bN_{\widehat{\bp_i}}$ by performing a union operation with the set of neighboring points whose indices change incrementally with $i$ in order to always represent the two neighbors of $\bp_i \in f$.

%
%
%
\subsection{Calculating Edge Lengths}
\label{ch5sSIssCEL}
In the next step, Algorithm~\ref{alg:serialCalculateEdgeLengths} calculates all the distinct edge lengths $\ell_{\svi}$ which are present in the mesh $\bM$, as well as the global minimum edge length $\gelm$.

As shown in Equation~\ref{eq:defineEdgeLengthPoint}, the calculation of an edge's length requires taking the L2-norm of the difference between two points, which involves using the square root operation. In modern software, the square root operation is performed by computing using Newton's method\todoCitation{software uses Newton's iteration for sqrt}, which is essentially multiple iterations of the so-called, recurrence equation\todoCitation{Newton's iteration uses recurrence equation}. This procedure is otherwise known as ``Newton's Iteration.'' ~\cite{Weisstein19b}

The impact for \forf{t} is that the computation of a square root typically\todoReword{add footnote with desc and citation}\todoCitation{how slow is Newton's iteration compared to others} takes many more compute cycles than other any other binary or unary operation, thus taking more time to complete overall. In fact, because of the slowness of the square root operation, computing the L2-norm in order to calculate an edge's length is empirically the most costly operation performed by the filter\todoResearch{qualify, do experiment to prove how slow sqrt is}. Therefore, it is imperative that we pay special attention to avoid unnecessary calls to calculate an edge's length. For that reason, we define the symbol $\ellstar$ to represent the calculation of an edge's length using "Newton's Iteration", so as to draw focus to its importance while designing an efficient implementation of \forf{t}.

So, while building this set outside of the principle loop requires ${\ellstar}$ to be calculated about $|\bP|^6$ times\footnote{depending on the average size of all neighborhoods, assumed here to be about 6}, it would be otherwise impossible to calculate the globally shortest edge length $\gelm$. However, if we also store the results of each edge length, doing so enables the main procedure to completely exclude all $\ellstar$ operations from the principle loop, and as we will see in Algorithm~\ref{alg:serialConvolveFilter}, that reduces the total count of $\ellstar$ operations which must be performed from $(2\,\ell_{\svi}^{\,border} + 4\,\ell_{\svi}^{\,non-border})\cdot\tau^{|\bP|}$, down to only the initial $1\cdot |\bP|^6$, becoming completely independent of $\tau$ and significantly more efficient overall than had the procedure been required to calculate an edge length each time it was used during computation.%
\nomenclature[gb]{$\ellstar$}{the procedure of calculating an edge's length using ``Newton's Iteration'', the most costly operation in the Fast One-Ring filter, due to use of $\sqrt{(\cdot)}$}%
\todoBackground{memory vs speed cost compromise}
\todoBackground{border vs non-border edge lengths}
\todoReword{three big paragraphs in a row is not pretty}

\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\Input{the set of all points $\bP$, \\
		the family of sets of discovered neighborhoods $\bN$}
	\Output{the set of pre-calculated edge-lengths $\bE$}

	\bigskip
	\FuncSty{calculateEdgeLengths}\FuncArgSty{($\bP$,\,$\bN$)}\;
\nl	\For{$\bp_v \in \bP$}{
\nl		\For{$\bp_i \in \bN_v$}{
			\linespread{1.5}\selectfont
\nl			$\ell_{\svi} \leftarrow |\bp_i - \bp_v|$\tcc*[r]{Eq:~\ref{eq:globalMinimumEdgeLength}}
\nl			$\gelm \leftarrow \min\left \{\gelm,\,\ell_{\svi}\right \}$\tcc*[r]{Eq:~\ref{eq:globalMinimumEdgeLength}}
		}
	}
	\caption{Serial algorithm for calculating all the edge lengths between each pair of adjacent points in the mesh\label{alg:serialCalculateEdgeLengths}}
\end{algorithm}%
\nomenclature[]{$\bE$}{the set of pre-calculated edge-lengths $\ell$}

%
%
%
\subsection{Convolving the Filter}
\label{ch5sSIssCF}
In the third and final part, we present Algorithm~\ref{alg:serialConvolveFilter}, which illustrates the remaining steps required to convolve \Forf{t}. After having completed the pre-calculations of Algorithms~\ref{alg:serialBuildNeighborhoods} and~\ref{alg:serialCalculateEdgeLengths}, each convolution is performed 
for a user-defined number of iterations $\tau$, 
by iterating over over the entire mesh $\bM$,
each point $\bp_j$,
which is a corner defining each half of the circle sector $\bs_i$,
which itself is defined by the point $\bp_i$, 
that when together, comprise each neighborhood $\bN_v$,
which is determined by each point $\bp_v$.

\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\Input{the set of all points $\bP$, \\
		the family of sets of discovered neighborhoods $\bN$, \\
		the chosen number of iteration $\bt$}
	\Output{new function values}

	\bigskip
	\linespread{1}\selectfont
	\FuncSty{convolveFilter}\FuncArgSty{($\bP$,\,$\bN$,\,$\bt$)}\;
	\nl\For{$\tau\leftarrow 1\;\KwTo\;\#iterations$}{
	\nl	\For{$\bp_v \in \bP$}{
	\nl		\For{$\bp_i \in \bN_v$}{
				\linespread{2.5}\selectfont
	\nl			$\kern-0.5pt\alpha \leftarrow cos^{-1}$
					\begin{Large}
						$\kern-6pt\left (\frac{\ell_c^2\,+\,\ell_b^2\,-\,\ell_a^2}{2\,\cdot\,\ell_c\,\cdot\,\ell_b}\right )$\tcc*[r]{Eq:~\ref{eq:alphaFromEdgeLengths}}
					\end{Large}
				\linespread{1.5}\selectfont
	\nl			$\kern0.00pt\beta \leftarrow (\pi - \alpha)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:betaFromHalfAlpha}}
	\nl			$\kern-1.5ptA \leftarrow \Big(\gelm\,\Big)^2\kern-4pt\cdot\alpha\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:circularSectorArea}}
	\nl			$\kern1.00pt\check{\ell} \leftarrow \big(4\cdot\gelm\cdot\sin(\alpha\mathbin{/}2)\big)\mathbin{/}3\,\alpha$\tcc*[r]{Eq:~\ref{eq:distToCoG}}
	\nl			$\kern1.00pt\zeta \leftarrow \gelm\mathbin{/}\sin(\beta)$\tcc*[r]{Eq:~\ref{eq:zeta}}
	\nl			\For{$j \in {1,2}$}{
	\nl				$\tilde{\ell}_j \leftarrow \zeta\mathbin{/}\ell_j$\tcc*[r]{Eq:~\ref{eq:distanceIForInterpolation},~\ref{eq:distanceIp1ForInterpolation}}
	\nl				$f'_j \leftarrow f_0\cdot(1 - \tilde{\ell}_j) + f_j\cdot\tilde{\ell}_j$\tcc*[r]{Eq:~\ref{eq:interpolatedFi},~\ref{eq:interpolatedFip1}}
				}
	\nl			$\check{f} \leftarrow f_0\cdot(1 - \check{\ell}) + \big((f'_1 + f'_2)\cdot\check{\ell}\big)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:weightedMeanAtCoGatSector}}
	\nl			$\kern-2.0pt\tilde{f}_v \leftarrow \tilde{f}_v + A\cdot f^{\bs}$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtPv}}
	\nl			$\kern-4.0pt\tilde{A}_v \leftarrow \tilde{A}_v + A$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtPv}}
			}

	\nl		$\bar{f}_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtPv}}
		}
	}
	\caption{Serial algorithm for convolving \Forf{t}\label{alg:serialConvolveFilter}}
\end{algorithm}%
\nomenclature[]{$\tilde{f}$}{}%
\nomenclature[]{$\tilde{A}$}{}%

As we leave this section, we move away from theoretical into implementation zone.\todoReword{transition from mathy to comp.sci implementation specific}

%
%
%
\section{Data Partitioning}%~\cite[p.~357]{Lang17}
%Data Partitioning is important.

%
%
%
\section[Acceleration by GPGPU]{Acceleration by General-purpose
computing on Graphics Processing Units (GPGPU)}

%
%
%
\section{Summary}
%then calculate all the edge lengths $\ell_{vk}$, as well as the global minimum edge length $\gelm$. Afterwards, one may efficiently convolve the filter, for as many number of iterations as required to achieve the desired smoothing effect.

