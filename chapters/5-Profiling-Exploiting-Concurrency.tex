\chapter{Profiling \& Exploiting Concurrency}
In the previous chapter we presented an improved version of the Fast One-Ring smoothing filter for scalar fields on discrete meshes as it is currently implemented within the GigaMesh framework, and while it has improved accuracy, it is entirely serial in design, so that unfortunately, its performance suffers greatly under the complexity of modern mesh sizes, which with the current high resolution scanners in use \todoCitation{hi rez scanners}... as large as \todoCitation{mesh sizes}. We will now endeavor to profile this as-yet-unpublished algorithm in order to discover opportunities for which we may improve upon its performance by exploiting any cuncurrency found.
\todoReword{is profile really the best word?}
%
\section{Serial Implementation}
\label{cFPECsSI}
In this section, we now combine all of the equations from the previous chapter,~\ref{eq:localMinimumEdgeLength} through~\ref{eq:meanFuncValAtP0}, into an algorithm using mathematical pseudo-code in order to facilitate the understanding the implementation of the improved Fast One-Ring smoothing filter.

The convolution of the filter requires several values which are shared between adjacent neighborhoods, and thus it is beneficial to split the algorithm into two distict parts, saving the results of the first part to be used in the iterative convolutions of the second part, all in order to reduce the number of required calculations-per-iteration.

Initially, one must discover all points $\bp_k$ which are members of each neighborhood $\bN_v$, then calculate all the edge lengths $\eta_{vk}$, as well as the global minimum edge length $\gDm$. Afterwards, one may efficiently convolve the filter, for as many number of iterations as required to achieve the desired smoothing effect.
\todoBackground{add adjacent neighborhoods to background}
\todoBackground{add convolution and convolve to background}
\todoBackground{mention how 3Ddata doens't save neighborhood information, and only winged pairs save edge info}
%
\subsection{Pre-Calculations}
In Algorithm~\ref{alg:buildNeighborhoods}, we discover the points $\bp_k \; \forall k \in \bN_v$ which are members of each neighborhood $\bN_v \; \forall v \in \bM$.
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\FuncSty{BuildNeighborhoods}\FuncArgSty{(a,b)}\;
\nl	\For{$f \in \mathcal{F}$}{
\nl		\For{$i \in \{0,1,2\}$}{
			\linespread{1.5}\selectfont
%seperated
%\nl			$\bp_a \leftarrow \bp_{\big((i\kern-.7pt\scalebox{0.66}{+}\kern-1.2pt1)\%3\big)}$\;
%\nl			$\bp_b \leftarrow \bp_{\big((i\kern-.7pt\scalebox{0.66}{+}\kern-1.2pt2)\%3\big)}$\;
%\nl			$\bN_{\widehat{\bp_i}} \leftarrow \bN_{\widehat{\bp_i}} \cup \{\bp_a, \bp_b\}$\;
%together
\nl			$\bN_{\widehat{\bp_i}} \leftarrow \bN_{\widehat{\bp_i}} \cup \{\bp_{\big((\sipo)\%3\big)}, \bp_{\big((\sipt)\%3\big)}\}$\;\label{BuildNeighborhoodsComplexSubscripts}
		}
	}
	\caption{Serial algorithm for discovering the neighborhoods required by the Fast One-Ring smoothing filter, before it can begin iteratively convolving a mesh\label{alg:buildNeighborhoods}}
\end{algorithm}%
\nomenclature[f01]{$\mathcal{F}$}{the set of Faces comprising the mesh}%
\nomenclature[f02]{$\widehat{\bp_i}$}{the unique index for point $\bp_i$, correspondign to $v \in \bM$}%

Algorithm~\ref{alg:buildNeighborhoods} uses complex subscripts in line~\ref{BuildNeighborhoodsComplexSubscripts}. The idea is to increment over all three of the vertices of each face $\mathcal{F}$ in the mesh. The symbol $\widehat{\bp_i}$ represents the unique index for point $\bp_i$, corresponding to $v \in \bM$, so that we can discover the neighborhood $\bN_{\widehat{\bp_i}}$ by performing a union operation with the set of neighboring points $\bp_{\big((\sipo)\%3\big)}, \bp_{\big((\sipt)\%3\big)}$, whose indexes change incrementally with $i$ in order to always represent the two neighbors of $\bp_i \in f$.

Next, in Algorithm~\ref{alg:serialGetEdgeLengths}, we calculate the edge lengths $\eta_{vk} \; \forall v \in \bM, \; \forall  k \in \bN_v$, as well as the global minimum edge length $\gDm$ of $\bM$.
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\FuncSty{GetEdgeLengths}\FuncArgSty{(a,b)}\;
\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
\nl		\For{$k\leftarrow 1\;\KwTo\;n_v$}{
			\linespread{1.5}\selectfont
\nl			$\eta_{vk} \leftarrow |\bp_k - \bp_v|$\label{precal-bpkbpv}\tcc*[r]{every edge length}
\nl			$\gDm \leftarrow \min\{\gDm, \eta_{vk}\}$\tcc*[r]{Eq:~\ref{eq:globalMinimumEdgeLength}}
		}
	}
	\caption{Serial algorithm for the calculations required by the Fast One-Ring smoothing filter, before it can begin iteratively convolving a mesh\label{alg:serialGetEdgeLengths}}
\end{algorithm}%
\nomenclature[f03]{$v$}{the cardinality of $\bN$ about $\bp_i$}%
\nomenclature[f04]{$k$}{the index for a point in $\bN_v$}%
\nomenclature[f05]{$\eta_{vk}$}{the length of the edge between $\bp_v$ and $\bp_k$}%
% If alg.1 changes, update refence to number of new symbols.

Algorithm~\ref{alg:serialGetEdgeLengths} introduces five new symbols: $v$ is used to represent a unique index for each vertex in $\bM$; $k$ indexes each neighboring point in the one-ring neighborhood $\bN_v$; whose cardinality is $n_v$, $|\bp_k-\bp_v|$ from line~\ref{precal-bpkbpv} is analogous to $|\bp_i-\bp_0|$ from Equation~\ref{eq:localMinimumEdgeLength} when $\bp_v$ becomes $\bp_0$; and lastly, $\eta_{vk}$ is the length of the edge between $\bp_v$ and $\bp_k$.
%
\subsection{Calculations}
In Algorithm~\ref{alg:serialCalculate}, we illustrate the remaining steps required to process a mesh using the one-ring filter, after having completed the pre-calculations in~\ref{alg:serialGetEdgeLengths}.
%
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\linespread{1}\selectfont
	\FuncSty{Calculate}\FuncArgSty{(a,b)}\;
\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
\nl		\For{$i \leftarrow 1\:\KwTo\:|\bN_v|$}{
			\linespread{2}\selectfont
\nl			$\alpha_i \leftarrow$ \begin{large}
				$\text{cos}^{-1}\Big(\frac{
					(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})^2 +
					(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})^2 -
					(\eta_{\widehat{\bp_{\sipo}},\widehat{\bp_{\sipt}}})^2
				}{2
					(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})
					(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})
				}\Big)$\tcc*[r]{Eq:~\ref{eq:alphaFromEdgeLengths}}
			\end{large}
			\linespread{1.5}\selectfont
\nl			$\beta_i \leftarrow (\pi - \alpha_i)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:betaFromHalfAlpha}}
\nl			\kern-2pt$A_i \leftarrow \gDm^2\alpha_i\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:circularSectorArea}}
\nl			\kern-7pt$\Dc_i \leftarrow \big(2\:\gDm\:\sin(\alpha_i\mathbin{/}2)\big)\mathbin{/}(3\alpha_i\mathbin{/}2)$\tcc*[r]{Eq:~\ref{eq:distToCoG}}
\nl			\kern1pt$\zeta_i \leftarrow \gDm\mathbin{/}\sin(\beta_i)$\tcc*[r]{Eq:~\ref{eq:zeta}}
\nl			\For{$j \in {1,2}$}{
\nl				\kern-8pt$\Dz_j \leftarrow \zeta_i\mathbin{/}|\bp_0 - \bp_j|$\tcc*[r]{Eq:~\ref{eq:distanceIForInterpolation},~\ref{eq:distanceIp1ForInterpolation}}
\nl				$f'_j \leftarrow f_0(1 - \Dz_j) + f_j\Dz_j$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0},~\ref{eq:interpolatedFip1}}
			}
\nl			$f^\bs_i \leftarrow f_0(1 - \Dc_i) + \big((f_1 + f_2)\Dc_i\big)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:weightedMeanAtCoGatSector}}
\nl			\kern-2pt$\tilde{A}_v \leftarrow \tilde{A}_v + A_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
\nl			$\tilde{f}_v \leftarrow \tilde{f}_v + A_if^{\bs}_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
		}

\nl		$\bar{f}_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
	}
	\caption{Serial algorithm for the Fast One-Ring smoothing filter for scalar fields on discrete manifolds\label{alg:serialCalculate}}
\end{algorithm}%
\nomenclature[f06]{$\eta^v_{1,2}$}{the length of the edge between $\bp_i$ and its neighbors in $\bt_i$, $\bp_1$ and $\bp_2$}%
%
\section{Data Partitioning}~\cite[p.~357]{Lang17}
Data Partitioning is important.


%
\section[Acceleration by GPGPU]{Acceleration by GPGPU (General-purpose
computing on graphics processing units)}

%
\section{Summary}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi tincidunt eget
ipsum eu iaculis. Cras vel sem eu velit eleifend porta vel sit amet massa. Etiam
a posuere nunc. Aenean aliquam viverra dapibus. Aliquam ac eros a purus feugiat
rhoncus. Donec faucibus ut nibh ut cursus. Aliquam erat volutpat. Proin efficitur
nulla sit amet iaculis condimentum. Cras placerat leo vitae venenatis feugiat. In
hac habitasse platea dictumst. Orci varius natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. In aliquet sagittis dui eu pulvinar.
Morbi a arcu eu dolor sagittis varius. Aliquam dignissim tortor sed tortor
suscipit, eget imperdiet mauris convallis.
