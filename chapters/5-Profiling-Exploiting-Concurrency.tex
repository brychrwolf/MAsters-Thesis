\chapter{Profiling \& Exploiting Concurrency}
In the previous chapter we presented an improved version of the Fast One-Ring smoothing filter for scalar fields on discrete meshes as it is currently implemented within the GigaMesh framework, and while it has improved accuracy, it is entirely serial in design so that unfortunately, its performance suffers greatly under the complexity of modern mesh sizes, which with the current high resolution scanners in use \todoCitation{hi rez scanners}... as large as \todoCitation{mesh sizes}. We will now endeavor to profile this as-yet-unpublished algorithm in order to discover opportunities to exploiting any cuncurrency and improve its performance.
\todoReword{is profile really the best word?}
%
\section{Serial Implementation}
\label{cFPECsSI}
In this section, with the goal of \sout{facilitating} understanding\todoReword{facilitating understanding sounds bad} of the implementation of the improved Fast One-Ring smoothing filter, we now combine all of the equations from the previous chapter,~\ref{eq:localMinimumEdgeLength} through~\ref{eq:meanFuncValAtP0} into an three-part algorithm using mathematical pseudo-code. \todoReword{better transition} The convolution of the filter requires that the one-ring neighborhoods be known and uses all edge lengths once per iteration, and twice for non-border edge lengths which are shared between adjacent neighborhoods. Thus, it is beneficial to split the algorithm into three distict parts, then save the results of the first two parts to be used in the iterative convolutions of the second part, all in order to increase efficency by reducing the number of calculations-per-iteration required.
\todoBackground{add adjacent neighborhoods to background}
\todoBackground{add convolution and convolve to background}
\todoBackground{mention how 3Ddata doens't save neighborhood information, and only winged pairs save edge info}
%
\subsection{Discover Neighborhoods}
Initially, one must discover all points $\bp_k \; \forall k \in \bN_v$ which are members of each neighborhood $\bN_v \; \forall v \in \bM$. Although building this family of sets outside of the principle loop adds an additional $2\cdot f^3$ operations, as we will see in Algorithm~\ref{alg:serialCompute}, doing so enables the main procedure to constrain a factor of the required operations to only $\tau^{(v^k)}$, significantly decreased from the $\tau^{(v^{|\mathcal{F}|})}$ otherwise needed, had the procedure been requried to discover the members of $\bN_v$ in each iteration.
\todoBackground{family of sets, https://en.wikipedia.org /wiki/Family\_of\_sets}
%
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\FuncSty{serialBuildNeighborhoods}\FuncArgSty{(a,b)}\;
\nl	\For{$f \in \mathcal{F}$}{
\nl		\For{$i \in \{0,1,2\}$}{
			\linespread{1.5}\selectfont
%seperated
%\nl			$\bp_a \leftarrow \bp_{\big((i\kern-.7pt\scalebox{0.66}{+}\kern-1.2pt1)\%3\big)}$\;
%\nl			$\bp_b \leftarrow \bp_{\big((i\kern-.7pt\scalebox{0.66}{+}\kern-1.2pt2)\%3\big)}$\;
%\nl			$\bN_{\widehat{\bp_i}} \leftarrow \bN_{\widehat{\bp_i}} \cup \{\bp_a, \bp_b\}$\;
%together
\nl			$\bN_{\widehat{\bp_i}} \leftarrow \bN_{\widehat{\bp_i}} \cup \left \{\bp_{\big((\sipo)\%3\big)}, \bp_{\big((\sipt)\%3\big)}\right \}$\;\label{serialBuildNeighborhoodsComplexSubscripts}
		}
	}
	\caption{Serial algorithm for discovering the neighborhoods required by the Fast One-Ring smoothing filter\label{alg:serialBuildNeighborhoods}}
\end{algorithm}%
\todoStyle{brackets are ugly}%
\nomenclature[fa]{$\mathcal{F}$}{the set of Faces comprising the mesh}%
\nomenclature[fb]{$\widehat{\bp_i}$}{the unique index for point $\bp_i$, correspondign to $v \in \bM$}%
\nomenclature[fc]{$\Ds$}{the most costly operation in the Fast One-Ring filter, due to use of $\sqrt{(\cdot)}$}%

Algorithm~\ref{alg:serialBuildNeighborhoods} uses complex subscripts in line~\ref{serialBuildNeighborhoodsComplexSubscripts}. The meaning is to increment over the set of points $\{\bp_0$, $\bp_1$, $\bp_2\}$, which define each face $\mathbf{f} \in \mathcal{F}$. The symbol $\widehat{\bp_i}$ represents the unique index for point $\bp_i$, corresponding to $v \in \bM$, so that we can discover the neighborhood $\bN_{\widehat{\bp_i}}$ by performing a union operation with the set of neighboring points $\left \{\bp_{\big((\sipo)\%3\big)}, \bp_{\big((\sipt)\%3\big)}\right \}$,\todoStyle{brackets are ugly} whose indices change incrementally with $i$ in order to always represent the two neighbors of $\bp_i \in f$.
\todoBackground{have defined $f$ already, and add to nomenclature, update entire document. deconflict with function symbol, should follow style of for faces $\mathbf{f}_i$, cardinality of should be $f$}
%
\subsection{Calculate Edge Lengths}
In the second part, Algorithm~\ref{alg:serialCalculateEdgeLengths}, we calculate the edge lengths $\eta_{vk} \; \forall v \in \bM, \; \forall  k \in \bN_v$, as well as the global minimum edge length $\gDm$. Although building this set outside of the principle loop requires ${\Ds}^{(v^k)}$ operations, where $\Ds$ is the most costly operation in the entire algorithm\todoCitation{calculating $\Ds$ is expensive}, as we will see in Algorithm~\ref{alg:serialCompute}, doing so enables the main procedure to completly exclude all $\Ds$ operations from the principle loop, reducing the total amount of times which $\Ds$ must be performed from ${(2\,\xi_{border} + 4\,\xi_{non-border})\cdot\tau^v}$ down to only the initial $1\cdot v^k$, which is completely independant of $\tau$ and significantly less than had the procedure been required to calculate an edge length each time it was used during computation.
\todoReword{mention memory costs}%
\todoBackground{add $\Ds$}%
\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\FuncSty{CalculateEdgeLengths}\FuncArgSty{(a,b)}\;
\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
\nl		\For{$k\leftarrow 1\;\KwTo\;n_v$}{
			\linespread{1.5}\selectfont
\nl			$\eta_{vk} \leftarrow |\bp_k - \bp_v|$\label{precal-bpkbpv}\tcc*[r]{$\Ds$ every edge length}
\nl			$\gDm \leftarrow \min\left \{\gDm, \eta_{vk}\right \}$\tcc*[r]{Eq:~\ref{eq:globalMinimumEdgeLength}}
		}
	}
	\caption{Serial algorithm for the calculations required by the Fast One-Ring smoothing filter\label{alg:serialCalculateEdgeLengths}}
\end{algorithm}%
\nomenclature[f03]{$v$}{the cardinality of $\bN$ about $\bp_i$}%
\nomenclature[f04]{$k$}{the index for a point in $\bN_v$}%
\nomenclature[f05]{$\eta_{vk}$}{the length of the edge between $\bp_v$ and $\bp_k$}%
% If alg.1 changes, update refence to number of new symbols.

Algorithm~\ref{alg:serialCalculateEdgeLengths} introduces five new symbols: $v$ is used to represent a unique index for each vertex in $\bM$; $k$ indexes each neighboring point in the one-ring neighborhood $\bN_v$; whose cardinality is $n_v$, $|\bp_k-\bp_v|$ from line~\ref{precal-bpkbpv} is analogous to $|\bp_i-\bp_0|$ from Equation~\ref{eq:localMinimumEdgeLength} when $\bp_v$ becomes $\bp_0$; and lastly, $\eta_{vk}$ is the length of the edge between $\bp_v$ and $\bp_k$.%
\todoReword{combine all $\xi \eta \delta$, all represent aan edge length}
%
\subsection{Computation}
In the third and final part, Algorithm~\ref{alg:serialCompute}, we illustrate the remaining steps required to convolve the Fast One-Ring smoothing filter, after having completed the pre-calculations in Algorithms~\ref{alg:serialBuildNeighborhoods} and~\ref{alg:serialCalculateEdgeLengths}. For a user-defined number of iterations $\tau$, one must iterate over each member of the neighborhood $\bp_i \in \bN_v, \forall v \in \bM$.


\begin{algorithm}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}

	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{things for filter}
	\Output{new function values}

	\bigskip
	\linespread{1}\selectfont
	\FuncSty{Calculate}\FuncArgSty{(a,b)}\;
	\nl\For{$\tau\leftarrow 1\;\KwTo\;\#iterations$}{
	\nl	\For{$v\leftarrow 1\;\KwTo\;m$}{
	\nl		\For{$i \leftarrow 1\:\KwTo\:n_v$}{
				\linespread{2}\selectfont
	\nl			$\alpha_i \leftarrow$ \begin{large}
					$\text{cos}^{-1}\Big(\frac{
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})^2 +
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})^2 -
						(\eta_{\widehat{\bp_{\sipo}},\widehat{\bp_{\sipt}}})^2
					}{2
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipt}}})
						(\eta_{\widehat{\bp_i},\widehat{\bp_{\sipo}}})
					}\Big)$\tcc*[r]{Eq:~\ref{eq:alphaFromEdgeLengths}}
				\end{large}
				\linespread{1.5}\selectfont
	\nl			$\beta_i \leftarrow (\pi - \alpha_i)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:betaFromHalfAlpha}}
	\nl			\kern-2pt$A_i \leftarrow \gDm^2\alpha_i\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:circularSectorArea}}
	\nl			\kern-7pt$\Dc_i \leftarrow \big(2\:\gDm\:\sin(\alpha_i\mathbin{/}2)\big)\mathbin{/}(3\alpha_i\mathbin{/}2)$\tcc*[r]{Eq:~\ref{eq:distToCoG}}
	\nl			\kern1pt$\zeta_i \leftarrow \gDm\mathbin{/}\sin(\beta_i)$\tcc*[r]{Eq:~\ref{eq:zeta}}
	\nl			\For{$j \in {1,2}$}{
	\nl				\kern-8pt$\Dz_j \leftarrow \zeta_i\mathbin{/}|\bp_0 - \bp_j|$\tcc*[r]{Eq:~\ref{eq:distanceIForInterpolation},~\ref{eq:distanceIp1ForInterpolation}}
	\nl				$f'_j \leftarrow f_0(1 - \Dz_j) + f_j\Dz_j$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0},~\ref{eq:interpolatedFip1}}
				}
	\nl			$f^\bs_i \leftarrow f_0(1 - \Dc_i) + \big((f_1 + f_2)\Dc_i\big)\mathbin{/}2$\tcc*[r]{Eq:~\ref{eq:weightedMeanAtCoGatSector}}
	\nl			\kern-2pt$\tilde{A}_v \leftarrow \tilde{A}_v + A_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
	\nl			$\tilde{f}_v \leftarrow \tilde{f}_v + A_if^{\bs}_i$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
			}

	\nl		$\bar{f}_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\tcc*[r]{Eq:~\ref{eq:meanFuncValAtP0}}
		}
	}
	\caption{Serial algorithm for the Fast One-Ring smoothing filter for scalar fields on discrete manifolds\label{alg:serialCompute}}
\end{algorithm}%
\nomenclature[f06]{$\eta^v_{1,2}$}{the length of the edge between $\bp_i$ and its neighbors in $\bt_i$, $\bp_1$ and $\bp_2$}%
%
\section{Data Partitioning}~\cite[p.~357]{Lang17}
Data Partitioning is important.


%
\section[Acceleration by GPGPU]{Acceleration by GPGPU (General-purpose
computing on graphics processing units)}

%
\section{Summary}
then calculate all the edge lengths $\eta_{vk}$, as well as the global minimum edge length $\gDm$. Afterwards, one may efficiently convolve the filter, for as many number of iterations as required to achieve the desired smoothing effect.

