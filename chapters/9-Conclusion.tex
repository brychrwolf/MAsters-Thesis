\chapter{Conclusions}
As of this writing, the fastest available GPGPU card available is the Quadro RTX 6000 which has 4,608 parallel processing cores and can perform at 16.3 TFLOPS~\cite{quadro6k}, up from the the previous 5000 model, which already had 3,702 and could perform at 11.2 TFLOPS~\cite{quadro5k}.

%
%
%
%
\subsubsection{Summary}

%
%
%
%
\section{Future Work}
What they are and why I did not.
\begin{itemize}
	\item Implement in OpenCL to include all GPUs
	\item Implement in OpenMP to use multiple machines
	\item Implement in PThreads to exploit MIMP
	\item Pipelining memory reads/calculations exploit more concurrency
	\item Edge case handling: max mesh size in memory, Derive calculation for compute time per iteration by mesh size. Maybe find when load time is greater than iteration time
	\item support other file types
	\item Calculating edge length takes longest, so DO NOT DOUBLE EFFORT HERE
	\item Determine is using $\elm$ vs $\bar{\elm}$ has any effect, especially on one-ring neighborhood with a relatively large $\elm$ on mesh with a very small $\bar{\elm}$
	\item More analysis on \fors. it is my intuition that the un-isotropic nature of the filter is due to the speed at which information travels along longer edges.
	\item Apply the filter to multi-channel vector fields like RGB, however color-wheel based methods may be better
	\item Implement Median and Mode version of filter (others based on what's foudn in 2d filter results)
	\item Implement more storage vs speed options
	\item explore using the inner angles $\alpha_i$ in stead of area for weighting
	\item instead of global min size, just choose a size, especially if not using sqrt to get edgelengths
\end{itemize}

