\chapter{Experiments \& Evaluation}
Our goal in experimentation was two-fold. It was our intuition that it would be useful to visualize the filter response when applied to acquired \tdd{} with the result of the MSII filter applied as a scalar field, and when applied to both regular and irregular synthetic \tdd{} with the Dirac delta function applied. Secondly, the performance of the parallel algorithm is evaluated in regards to speedup obtained when convolving the filter over meshes of different sizes, with different counts of processors.

A smoothing filter is an application of the Heat equation \todoCitation{Jaehne}
Gaussian distribution
Gaussian blurring

Two purposes:
	1. see the behavior of the filter in different data sets, and to
	1. compare the speedup obtained on given different problem sizes and processor counts

Two kinds of data sets:
	synthetic
		square tessallations 2 and 4 triangles
		hexagonal tessalations
		disc triangulation
	acquired

Each image of a mesh was visualized using GigaMesh~\cite{Mara10} with function values colored with the Improved Hot colorramp, exported as a raster image in the portable network graphic, PNG, format.%after disabling the background grid [f7], maximizing the window, disabling screenshot cropping, as well as rejecting tiled rendering, finally cropping to content in GIMP.


%
%
%
%
%
%
\section{Synthetic Data}
In order to study the effect of each convolution of \fors{t} on individual values of a scalar field, we generated synthetic \tdd{} arranged into four different configurations of triangle meshes, then applied the Dirac delta function as a scalar field\todoCitation{Dirac delta function}, meaning a function value of one at the center point, and zero everywhere else, before iteratively convolving the filter multiple times on each mesh.

The four synthetic mesh configurations are: the bisected square tessellation, the quadrisected square tesselation, the hexagonal tessellation, and the random triangulated disc, and were generated using C++ source code which was written specifically for the research presented in this thesis. However, as such tools may also be found useful by other researchers, it is our intention to make that source code of each generator as available as this thesis to the others.



, with eight different sizes of each,
%
%
%
%
\pagebreak
\subsection{Bisected Square Tessellations}
The synthetic mesh generator for bisected square tessellations generates meshes which are characterized by rings of squares around a center point, with the northwest and southeast corners made adjacent, so as to bisect the square into two equally sized isosceles, right triangles; resulting in two dissimilar edge lengths adjacent to the center point.

The smallest, non-trivial mesh, generated with the parameter R equal to one, is composed of four squares around the center point, represented in total by only nine points and eight faces, however those numbers grow quickly
%, as summarized in table~\ref{tbl:sq2},
with increasing parameter size R, according to the two equations
\begin{align}
	|\bP| &= 4R^2 + 4R + 1 \\
	|\bT| &= 8R^2
	\label{eq:sq2PointAndFaceCounts}
\end{align}

%\begin{table}[ht]
%\begin{tabular}{rrr}
%\textbf{R} & \textbf{Points} & \textbf{Faces} \\
%\hline
%    0 &          1 &          0\\
%    1 &          9 &          8\\
%    3 &         49 &         72\\
%   10 &        441 &        800\\
%   30 &      3,721 &      7,200\\
%  100 &     40,401 &     80,000\\
%  300 &    361,201 &    720,000\\
%1,000 &  40,04,001 &  8,000,000\\
%3,000 & 36,012,001 & 72,000,000%
%\caption{Summary of the Counts of Points and Faces for Increasing Parameters of the Bisected Square Tesselation Synthetic Mesh Generator\label{tbl:sq2}}
%\end{tabular}
%\end{table}

Figure~\ref{fig:sq2} shows a comparison of two differently sized bisected square tessellations, generated with parameters R set to 1 and 10, each in wireframe, shown in (a) and (d), then colored by function value before convolving the filter, shown in (b) and (e), as well as after convolving the filter, once for R=1 in (c), and 100 times for R=10 in (f). Notice how the filter response appears to travel faster across the image, along the longer, diagonal edge lengths.

\input{figures/latex/sq2.tex}
%\todoResearch{Why does sq2 10 need 100 iters to match sq 1 at 1 iters?}

%
%
%
%
\pagebreak
\subsection{Quadrisected Square Tessellations}
The synthetic mesh generator for quadirsected square tessellations generates meshes which are characterized by rings of squares around a center point, with the every corner made adjacent to the center point, quadrisecting the square into four equally sized isosceles, right triangles.

The smallest, non-trivial mesh, generated with the parameter R equal to one, is composed of four squares around the center point, represented in total by only nine points and eight faces, however those numbers grow quickly
%, as summarized in table~\ref{tbl:sq2},
with increasing parameter size R, according to the two equations
\begin{align}
	|\bP| &= 4R^2 + 4R + 1 \\
	|\bT| &= 8R^2
	\label{eq:sq2PointAndFaceCounts}
\end{align}

%\begin{table}[ht]
%\begin{tabular}{rrr}
%\textbf{R} & \textbf{Points} & \textbf{Faces} \\
%\hline
%    0 &          1 &          0\\
%    1 &          9 &          8\\
%    3 &         49 &         72\\
%   10 &        441 &        800\\
%   30 &      3,721 &      7,200\\
%  100 &     40,401 &     80,000\\
%  300 &    361,201 &    720,000\\
%1,000 &  40,04,001 &  8,000,000\\
%3,000 & 36,012,001 & 72,000,000%
%\caption{Summary of the Counts of Points and Faces for Increasing Parameters of the Bisected Square Tesselation Synthetic Mesh Generator\label{tbl:sq2}}
%\end{tabular}
%\end{table}

Figure~\ref{fig:sq2} shows a comparison of two differently sized bisected square tessellations, generated with parameters R set to 1 and 10, each in wireframe, shown in (a) and (d), then colored by function value before convolving the filter, shown in (b) and (e), as well as after convolving the filter, once for R=1 in (c), and 100 times for R=10 in (f). Notice how the filter response appears to travel faster across the image, along the longer, diagonal edge lengths.

%
%
%
%
\pagebreak
\subsection{Hexagonal Tesselation}
The synthetic mesh generator for hexagonal tessellations generates meshes which are characterized by hexagons around one central hexagon, with each corner of a hexagon made adjacent to its center point, creating six equilateral triangles, and ensuring that every edge lengths in the mesh is of equal size.

The smallest, non-trivial mesh, generated with the parameter R equal to one, is composed of one hexagon around the center point, represented in total by only seven points and 6 faces, however those numbers grow quickly
%, as summarized in table~\ref{tbl:hex},
with increasing parameter size R, according to the two equations
\begin{align}
	|\bP| &= 3R^2 + 3R + 7 +\sum_{r=1}^R{6(2r + 1)}\\
	|\bT| &= 18R^2 + 18R + 6
	\label{eq:hexPointAndFaceCounts}
\end{align}

%\begin{table}[ht]
%\begin{tabular}{rrr}
%\textbf{R} & \textbf{Points} & \textbf{Faces} \\
%\hline
%    0 &          7 &           6\\
%    1 &         31 &          42\\
%    3 &        133 &         222\\
%   10 &      1,057 &       1,986\\
%   30 &      8,557 &      16,746\\
%  100 &     91,507 &     181,806\\
%  300 &    814,507 &   1,625,406\\
%1,000 &  9,015,007 &  18,018,006\\
%3,000 & 81,045,007 & 162,054,006%
%\caption{Summary of the Counts of Points and Faces for Increasing Parameters of the Hexagonal Tesselation Synthetic Mesh Generator\label{tbl:hex}}
%\end{tabular}
%\end{table}

Figure~\ref{fig:sq2} shows a comparison of two differently sized hexagonal tessellations, generated with parameters R set to 1 and 10, each in wireframe, shown in (a) and (d), then colored by function value before convolving the filter, shown in (b) and (e), as well as after convolving the filter, once for R=1 in (c), and 200 times for R=10 in (f).

\input{figures/latex/hex.tex}

%
%
%
%
\pagebreak
\subsection{Random Triangulated Discs}
The synthetic mesh generator for random triangulated discs generates meshes which are characterized by radially bounded, uniformly distributed, random meshes; including one point located at the origin. Furthermore, the points are then triangulated following the well-studied method originally presented by of Delaunay~\cite{Delaunay34}.
\todoResearch{how are the points uniformly distributed?}

Unlike the other generators, this requires two parameters, the radius of the disc R, and the explicit number of points P. For our experiments, the parameters were chosen to ensure parity with the sizes and point density of the other synthetic meshes.
%, the following table of parameters where used.
%\begin{table}[ht]
%\begin{tabular}{rrr}
%\textbf{R} & \textbf{Points} & \textbf{Faces} \\
%\hline
%1	11
%3	67
%10	641
%30	5521
%100	60401
%300	541201
%1000	6004001
%3000	54012001

%   0 &          7 &           6\\
%    1 &         31 &          42\\
%    3 &        133 &         222\\
%   10 &      1,057 &       1,986\\
%   30 &      8,557 &      16,746\\
%  100 &     91,507 &     181,806\\
%  300 &    814,507 &   1,625,406\\
%1,000 &  9,015,007 &  18,018,006\\
%3,000 & 81,045,007 & 162,054,006%
%\caption{Summary of the Counts of Points and Faces for Increasing Parameters of the Hexagonal Tesselation Synthetic Mesh Generator\label{tbl:hex}}
%\end{tabular}
%\end{table}

%The smallest, non-trivial mesh, generated with the parameter R equal to one, is composed of one hexagon around the center point, represented in total by only seven points and 6 faces, however those numbers grow quickly with increasing parameter size R, according to the two equations
%\begin{align}
%	|\bP| &= 3R^2 + 3R + 7 +\sum_{r=1}^R{6(2r + 1)}\\
%	|\bT| &= 18R^2 + 18R + 6
%	\label{eq:hexPointAndFaceCounts}
%\end{align}

Figure~\ref{fig:sq2} shows a comparison of two differently sized, random triangulated discs, generated with parameters R set to 1 and 10, and parameters P set to 11 and 641, each in wireframe, shown in (a) and (d), then colored by function value before convolving the filter, shown in (b) and (e), as well as after convolving the filter, twice for R=1 in (c), and 10,000 times for R=10 in (f).

\input{figures/latex/rdisc.tex}

%
%
%
%
%
%
\pagebreak
\section{Acquired Data}
\dots

%
%
%
%
\subsection{University Seal}
Unisiegel\_\- UAH\_\- Ebay-Siegel\_\- Uniarchiv\_\- HE2066-60\_\- 010614\_\- partial\_\- ASCII.ply
%\input{figures/latex/unisiegel.tex}

%
%
%
%
\subsection{A Flat surface}
Flat surfaces have NOISE!
Figure~\ref{fig:ILATO}: ILATO\_1A\_SM2066-HE5-60\_070214\_merged\_GMO\_r1.00\_n4\_v256
%\input{figures/latex/ILATO.tex}

%
%
%
%
\subsection{Stanford Bunny}
Figure~\ref{fig:bun}: http://graphics.stanford.edu/data/3Dscanrep/ (Stanford Bunny)
%\input{figures/latex/bun.tex}

%
%
%
%
%
%
\section{Evaluation}
\ldots

%
%
%
%
\subsection{Compute Times}

Figure~\ref{fig:computeTimesLP} shows how compute times increase linearly with both mesh size and number of iterations in a very predictable way when total compute time is at least 0.1 seconds, and less predictable for shorter periods do to the nature of thread optimization at the processor level and variable memory read times.\todoResearch{add formula for timing (or at least ref to it) here.}\todoResearch{process time noise at very fast speeds}
\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\linewidth,height=1.0\textheight,keepaspectratio]
		{figures/computeTimesLinespoints.png}
	\RawCaption{\caption[Compute Times - Linespoints]{Compute Times of Applying
		the	One-Ring Filter for Selected Numbers of Iterations onto Acquired and
		Synthetic 3D Meshes of Varying Sizes}
		\label{fig:computeTimesLP}}
\end{figure}

Figure~\ref{fig:computeTimesS} shows how compute times increase with both meshsize and number of iterations.\todoCitation{wikipedia Euler characteristic Polyhedra}
\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\linewidth,height=1.0\textheight,keepaspectratio]{figures/computeTimesScatter.png}
	\RawCaption{\caption[Compute Times - Scatter]{Compute Times for Different
		Hardware Configurations by increaseing Mesh Size and Filter Iterations}
		\label{fig:computeTimesS}}
\end{figure}

%
%
%
%
\subsection{Curious Trend, ratio goes to 2}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\linewidth,height=1.0\textheight,keepaspectratio]{figures/numFacesByVerticesGoTo2.png}
	\RawCaption{\caption[Ratio of Faces / Vertices]{Ratio of Faces to Vertices by
		Increasing Vertex Count}
		\label{fig:ratioFacesVertices}}
\end{figure}



%\subsection{Debossed H}
%In Figure \ref{fig:h}, we show a debossed capital letter H.\footnote{The H is
%as a nod to Heidelberg University and the cuniform script studied by the FCGL.}
%\begin{figure}[ht]
%\centering
%	\begin{subfigure}{.48\linewidth}
%		\centering
%		\resizebox{0.48\linewidth}{!}{\input{data/synthetic_meshes/h.tikz_labels.tex}}
%		\caption{HWireframe}\label{fig:h.a}
%	\end{subfigure}
%	\hfill
%	\begin{subfigure}{.48\linewidth}
%		\centering
%		\includegraphics[width=0.48\linewidth]{data/synthetic_meshes/h_colored.png}
%		\caption{HColored}\label{fig:h.b}
%	\end{subfigure}
%	\caption[A debossed H, which contains 22 vertices and 36 faces.]{A debossed H,
%	which contains 22 vertices and 36 faces: (a) wireframe (b) colored by the
%	relation to its distance to an underlying plane, in RdGy
%	colorramp~\cite[p.~???]{Brewer2003}~\cite[p.~19]{Giga17}, visualized using the
%	GigaMesh~\cite{Mara10} framework with triangle edges rendered.}\label{fig:h}
%\end{figure}
%To evaluate methods available for discrete surfaces, we can increase the number of vertices of our synthetic wedge using five iterations of the mid-edge subdivision scheme [PR97,HW99].~\cite[p.~38]{Mara12}

%\subsection{Mars Crater}
%Mars dataset crater as a Digital Terrain Models (DTMs) Mention in Mara 3.6
%Summary “Dali” inspired methodProcessing regular grids like Digital Terrain Models (DTMs) will gain dramatic performance increases using the estimator, while processing irregular grids with high curvatures will strongly benefit from precise computation of the volume integral invariant.~\cite[p.~143]{Mara12}

%
%
%
%
%
%
\section{Summary}
\dots
