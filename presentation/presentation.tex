\documentclass[aspectratio=169,t]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{color}
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage[vlined]{algorithm2e}
\usepackage{standalone}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows.meta}
\usepackage{anyfontsize}
%\usepackage{enumitem}

\usepackage{beamerthemesplit}
\usetheme[compress]{Heidelberg}
\definecolor{unirot}{rgb}{0.5976525,0,0}
\usecolortheme[named=unirot]{structure}

\title{GPGPU Accelerated Iterative Filtering of Scalar Fields on Discrete Manifolds}
\author{Bryan Wolfford}

\institute[Uni HD]{
	Universit√§t Heidelberg\\
	Interdisciplinary Center for Scientific Computing\\
	Forensic Computational Geometry Laboratory\\
	\color{unirot}{wolfford@stud.uni-heidelberg.de}
}
\date{\today}

%\AtBeginSection[]{
%	\begin{frame}<beamer>
%		\frametitle{Outline}
		% show TOC and highlight current section
%		\tableofcontents[currentsection]
%	\end{frame}
%}

%\AtBeginSubsection[]{
%	\begin{frame}<beamer>
%		\frametitle{Outline}
		% show TOC and highlight current section
%		\tableofcontents[currentsection,currentsubsection]
%	\end{frame}
%}

\begin{document}
\input{../myCommands.tex}
\setlength{\intextsep}{0pt}
\def\hilite<#1>{\temporal<#1>{\color{black}}{\color{unirot}}{\color{gray}}}
\frame[plain]{\titlepage}
\frame{\frametitle{Outline}\tableofcontents}




%================================================
%================================================
\section{Motivation \& Introduction}

%------------------------------------------------
\frame{\frametitle{Motivation}
	\begin{itemize}
		\item Increasing demand for high-definition \tdd{}
		\begin{itemize}
			\item Industrial quality scanning
			\item Fuzzy borders on hieroglyphs
			\item OCR
		\end{itemize}

		\item Danger to physical archives
		\begin{itemize}
			\item 2018 Brazilian museum fire destroyed 20 million artifacts
		\end{itemize}
	\end{itemize}

%\section{Motivation}
%3D-Data is important to many fields
%From industrial quality scanning~\cite{ILATO14}, to computerized analysis of documents and artifacts within the Digital Humanities~\cite{Bogacz15}, the demand for high-definition \tdd{} is only increasing. And in light of recent tragedies befalling global physical archives, like the museum fire which destroyed Brazil's oldest museum and its 20 million artifacts~\cite{Andreoni18}, or the numerous war zones occupying archaeologically important sites, 3D-scanning will continue to increase in importance.

%3D-Data Noises in data, so must still process
%However, raw \tdd{} is typically not suitable for analysis~\cite[p.~25-32]{Mara12}, so processing and pre-processing with a smoothing filter becomes necessary. In dense, high-resolution meshes, for example, one can see noise propagating as jagged outlines in segment boundaries of connected components when visualizing the output of filters designed for analysis, like the Multi-Scale Integral Invariants filter (MSII)~\cite[s.~3.2]{Mara17}.

%processing is difficult
%One major complication slowing the development of filters for \tdd{} has been that the window size of any filter must remain static for the duration of its convolution, in order for the output response to be mapped correctly back onto the input field~\cite[p.~106-112]{Jaehne97}. While it is trivial to define a static-sized filter for convolving regular meshes like raster images, it is a complex and complicated task to create the same for convolving acquired \tdd{}, whose one-ring neighborhoods are subsets of non-planar meshes embedded in $\bR{3}$, uniformly irregular, with completely arbitrary shapes, sizes, and counts of members~\cite[p.~29]{Mara12}~\cite[s.~3.2]{Mara17}.

%3D-Data is big. serial is slow
%Another problem which arises, is that with high-resolution 3D-scanning, the data output is often comprised of millions, or tens of millions, of points per scanned item and features several hundred points per mm$^2$~\cite[25,144]{Mara17}~\cite[4]{ILATO14}. At that scale, serial algorithms processing that data can no longer be included in the regular workflow of a scientist analyzing the artifacts, because each operation can easily take hours or days to complete.


%gpgpus are cheap, so do the thing
%Fortunately, with the introduction of GPGPUs to the commercial market, individual research groups now have the opportunity to exploit the parallel processing power of SIMD systems, without needing access to an institutional supercomputer. Therefore, the motivation for designing a smoothing filter, which can efficiently convolve over large, irregular, acquired \tdd{} by utilizing commercially available GPGPUs, was realized. Thus came \Fors{t}, and the research presented in this thesis.
}

%------------------------------------------------
\frame{\frametitle{Introduction}

}

%------------------------------------------------
\frame{\frametitle{SIMD Architecture}
	\includegraphics[width=1.0\linewidth]{../figures/tikz/simdArchitecture.pdf}
	GPUs, Supercomputers, Computer Pools %Name examples like the cray, and pool in this building
}

%------------------------------------------------
\frame{\frametitle{CPU vs GPU Construction}
	\includegraphics[width=1.0\linewidth]{../figures/cpuvgpu.png}
}

%------------------------------------------------
%\frame{\frametitle{Calculating Square Roots on a Computer}
%	Maximize efficiency by minimizing doing these.
%}

%------------------------------------------------
\frame{\frametitle{One-Ring Neighborhoods in Regular and Irregular Meshes}
	\includegraphics[width=1.0\linewidth]{../figures/neighborhoods_presentation.png}
	\begin{columns}[c]
		\begin{column}{.33\textwidth}
			a regular square mesh, as in pixels of a digital image
		\end{column}
		\begin{column}{.33\textwidth}
			a regular triangle mesh, as in a hexagonal tessellation
		\end{column}
		\begin{column}{.33\textwidth}
			an irregular triangle mesh, typical of acquired \tdd{}.
		\end{column}
	\end{columns}
}

%------------------------------------------------
\frame{\frametitle{Function Values as a Scalar Field}
	\begin{columns}[c]
		\begin{column}{.75\textwidth}
			\includegraphics[width=1.0\linewidth]{../figures/visualizeFunctionValues2.png}
		\end{column}
		\begin{column}{.25\textwidth}
			Visualization of the curvature of function values feature boundries, connected segments, cuneiform tablets
		\end{column}
	\end{columns}
}




%================================================
%================================================
\section{Fast One-Ring Smoothing}


%================================================
\subsection{Mathematical Foundation}

%------------------------------------------------
\frame{\frametitle{A One-Ring Neighborhood and its Geodesic Disc}
	\centering
	\includegraphics[width=0.8\linewidth]{../figures/geodesicDisc_presentation.png}
	\begin{align*}
		\elm(\bp_0) &:= \min_{\forall \bp_i \in \bN_v}|\bp_i - \bp_0| \\
		\gelm &:= \min\left \{\elm(\bp_0) \;|\; \bp_0 \in \bM\,\right \}
	\end{align*}
}

%------------------------------------------------
\frame{\frametitle{An Enhanced View of a Circle Sector}
	\includegraphics[width=0.5\linewidth]{../figures/anglesAndCenterOfGravity_presentation.png}
}

%------------------------------------------------
\frame{\frametitle{Interpolation of Function Values toward the Center of Gravity}
	\centering
	\includegraphics[width=0.9\linewidth]{../figures/interpolatedFunctionValues.png}
}

%------------------------------------------------
\frame{\frametitle{Weighted Mean Function Value $f'_v$ at $\bp_v$}
	\includegraphics[width=1.0\linewidth]{../figures/funcValVolumes_presentation.png}
}


%================================================
\subsection{Serial Algorithm}

%------------------------------------------------
\frame{\frametitle{Union Operations as Performed in Build Neighborhoods}
	\begin{columns}[t]
		\begin{column}{.6\textwidth}
			\includegraphics[width=1.0\linewidth]{../figures/triangularFaces.png}
		\end{column}
		\hspace*{-1.5cm}
		\begin{column}{.6\textwidth}
			\includestandalone[width=1.0\linewidth]{../figures/tikz/unionsOfSimpleBuildNeighborhoods}
		\end{column}
	\end{columns}

	\begin{columns}[t]
		\begin{column}{.5\textwidth}
			\begin{algorithm}[H]
				\DontPrintSemicolon
				\SetKwFor{For}{for}{:}{}
				\begin{block}{}
				\nl		\For{$\bt \in \bT$}{
				\nl			\ProgSty{union($\bN$, $\bp_a$, $\bp_b$, $\bp_c$)}\;
				\nl			\ProgSty{union($\bN$, $\bp_b$, $\bp_a$, $\bp_c$)}\;
				\nl			\ProgSty{union($\bN$, $\bp_c$, $\bp_a$, $\bp_b$)}\;
						}
				\end{block}
			\end{algorithm}
		\end{column}
		\begin{column}{.5\textwidth}
			\begin{algorithm}[H]
				\DontPrintSemicolon
				\SetKwFor{For}{for}{:}{}
				\SetKwProg{Func}{Function}{}{}
				\begin{block}{}
				\nl	\Func{union($\bN$, $a$, $b$, $c$)}{
				\nl		$\bN_a \leftarrow \bN_a \cup \{b,\,c\}$\;
					}
				\end{block}
			\end{algorithm}
		\end{column}
	\end{columns}
}

%------------------------------------------------
\frame{\frametitle{Serial Algorithm for Calculating Edge Lengths}
\begin{algorithm}[H]
	\SetAlgoSkip{}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwProg{Func}{Function}{}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\only<1>{
	\begin{block}{}%Part (1 of 1)}
		\Input{the set of all points $\bP$, \\
			the set of discovered neighborhoods $\bN$}
		\Output{the set of pre-calculated edge lengths $\bE$, \\
			the minimum edge length of the mesh $\gelm$}

		\bigskip
	\nl	\Func{serialCalculateEdgeLengths($\bP$, $\bN$)}{
	\nl		\For{$\bp_v \in \bP$}{
	\nl			\For{$\bp_i \in \bN_v$}{
					\linespread{1.5}\selectfont
	\nl				$\bE_{\sv{i}} \leftarrow |\bp_i - \bp_v|$\tcc*[r]{This is $\ellstar$}
	\nl				$\gelm \leftarrow \min\left \{\gelm,\,\bE_{\sv{i}}\right \}$\;
				}
			}
		}
	\end{block}
	}
\end{algorithm}
}

%------------------------------------------------
\frame{\frametitle{Serial Algorithm for Convolving the Filter}
	\vspace*{-8mm}
	\begin{columns}
		\begin{column}[t]{.35\textwidth}
			\begin{block}{}
				{\fontsize{4.2}{4.2}\selectfont
					\begin{algorithm}[H]
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
						\Input{the set of all points $\bP$, \\
							the set of discovered neighborhoods $\bN$, \\
							the set of pre-calculated edge lengths $\bE$, \\
							the minimum edge length of the mesh $\gelm$, \\
							the set of function values $\bF$, \\
							the user-defined number of convolutions $\tau$}
						\Output{the set of one-ring \wmfv{s} $\bF'$}

						\medskip
						\linespread{1.2}\selectfont
					\nl	\Func{serialConvolveFilter($\bP$, $\bN$, $\bE$, $\gelm$, $\bF$, $\tau$)}{
					\nl		\For{$t\leftarrow 1\;\KwTo\;\tau$}{
					\nl			\For{$\bp_v \in \bP$}{
					\nl				\For{$\bp_i \in \bN_v$}{
										\linespread{1.5}\selectfont
					\nl					$\kern-0.5pt\alpha \leftarrow cos^{-1} \kern-6pt\left (\frac{\bE_c^2\,+\,\bE_b^2\,-\,\bE_a^2}{2\,\cdot\,\bE_c\,\cdot\,\bE_b}\right )$\;
										\linespread{1.2}\selectfont
					\nl					$\kern0.00pt\beta \leftarrow (\pi - \alpha)\mathbin{/}2$\;
					\nl					$\kern-1.5ptA \leftarrow \Big(\gelm\,\Big)^2\kern-4pt\cdot\alpha\mathbin{/}2$\;
					\nl					$\kern1.00pt\check{\ell} \leftarrow \big(4\cdot\gelm\cdot\sin(\alpha\mathbin{/}2)\big)\mathbin{/}3\,\alpha$\;
					\nl					$\kern1.00pt\zeta \leftarrow \gelm\mathbin{/}\sin(\beta)$\;
					\nl					\For{$j \in {1,2}$}{\label{algSCFjloop}
					\nl						$\tilde{\ell}_j \leftarrow \zeta\mathbin{/}\bE_j$\;
					\nl						$f'_j \leftarrow f_0\cdot(1 - \tilde{\ell}_j) + f_j\cdot\tilde{\ell}_j$\;
										}
					\nl					$\check{f} \leftarrow f_0\cdot(1 - \check{\ell}) + \big((f'_1 + f'_2)\cdot\check{\ell}\big)\mathbin{/}2$\;
					\nl					$\kern-2.0pt\tilde{f}_v \leftarrow \tilde{f}_v + A\cdot\check{f}$\;
					\nl					$\kern-4.0pt\tilde{A}_v \leftarrow \tilde{A}_v + A$\;
									}
					\nl				$f'_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\;
								}
					\nl		$\bF' \leftarrow \left \{f'_1,\ldots,\,f'_{|\bP|}\right \}$\;
					\nl 	$\bF \leftarrow \bF'$\;
							}
						}
					\end{algorithm}
				}
			\end{block}
		\end{column}
		\begin{column}[t]{.65\textwidth}				
			\only<1>{
				\begin{block}{Part (1 of 3)}
					\begin{algorithm}[H]
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
						\Input{the set of all points $\bP$, \\
							the set of discovered neighborhoods $\bN$, \\
							the set of pre-calculated edge lengths $\bE$, \\
							the minimum edge length of the mesh $\gelm$, \\
							the set of function values $\bF$, \\
							the user-defined number of convolutions $\tau$}
						\Output{the set of one-ring \wmfv{s} $\bF'$}
					\end{algorithm}
				\end{block}
			}\only<2>{
				\begin{block}{Part (2 of 3)}
					\begin{algorithm}[H]
						\SetAlgoLined
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\setcounter{AlgoLine}{0}
					\nl	\Func{serialConvolveFilter($\bP$, $\bN$, $\bE$, $\gelm$, $\bF$, $\tau$)}{
					\nl		\For{$t\leftarrow 1\;\KwTo\;\tau$}{
					\nl			\For{$\bp_v \in \bP$}{
					\nl				\For{$\bp_i \in \bN_v$}{
										\vspace*{1.5\baselineskip}
										\ldots
										\vspace*{1.5\baselineskip}
									}
						\setcounter{AlgoLine}{15}
					\nl				$f'_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\;
								}
					\nl		$\bF' \leftarrow \left \{f'_1,\ldots,\,f'_{|\bP|}\right \}$\;
					\nl 	$\bF \leftarrow \bF'$\;
							}
						}
					\end{algorithm}
				\end{block}
			}\only<3>{
				\begin{block}{Part (3 of 3)}
					{\fontsize{9}{9.5}\selectfont
					\begin{algorithm}[H]
						\SetAlgoLined
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\setcounter{AlgoLine}{7}
						\vspace*{-1\baselineskip}
						\Cont{}{
							\vspace*{-1\baselineskip}
							\Cont{}{
								\vspace*{-1\baselineskip}
								\Cont{}{
									\vspace*{-1\baselineskip}
									\Cont{}{					
										\linespread{1.5}\selectfont
					\nl					$\kern-0.5pt\alpha \leftarrow cos^{-1} \kern-6pt\left (\frac{\bE_c^2\,+\,\bE_b^2\,-\,\bE_a^2}{2\,\cdot\,\bE_c\,\cdot\,\bE_b}\right )$\;
										\linespread{1.2}\selectfont
					\nl					$\kern0.00pt\beta \leftarrow (\pi - \alpha)\mathbin{/}2$\;
					\nl					$\kern-1.5ptA \leftarrow \Big(\gelm\,\Big)^2\kern-4pt\cdot\alpha\mathbin{/}2$\;
					\nl					$\kern1.00pt\check{\ell} \leftarrow \big(4\cdot\gelm\cdot\sin(\alpha\mathbin{/}2)\big)\mathbin{/}3\,\alpha$\;
					\nl					$\kern1.00pt\zeta \leftarrow \gelm\mathbin{/}\sin(\beta)$\;
					\nl					\For{$j \in {1,2}$}{\label{algSCFjloop}
					\nl						$\tilde{\ell}_j \leftarrow \zeta\mathbin{/}\bE_j$\;
					\nl						$f'_j \leftarrow f_0\cdot(1 - \tilde{\ell}_j) + f_j\cdot\tilde{\ell}_j$\;
										}
					\nl					$\check{f} \leftarrow f_0\cdot(1 - \check{\ell}) + \big((f'_1 + f'_2)\cdot\check{\ell}\big)\mathbin{/}2$\;
					\nl					$\kern-2.0pt\tilde{f}_v \leftarrow \tilde{f}_v + A\cdot\check{f}$\;
					\nl					$\kern-4.0pt\tilde{A}_v \leftarrow \tilde{A}_v + A$\;
									}
								}
							}
						}
					\end{algorithm}
					}
				\end{block}
			}
		\end{column}
	\end{columns}
	\begin{tikzpicture}[overlay, remember picture]
		\draw<1>[unirot,ultra thick,rounded corners] (-8mm, 64mm) rectangle (46mm, 50mm);
		\draw<2>[unirot,ultra thick,rounded corners] (-8mm, 50mm) rectangle (46mm, 41mm);
		\draw<2>[unirot,ultra thick,rounded corners] (-8mm, 15mm) rectangle (46mm,  2mm);
		\draw<3>[unirot,ultra thick,rounded corners] (-8mm, 43mm) rectangle (46mm, 14mm);
	\end{tikzpicture}
}


%================================================
\subsection{Data Dependencies}

%------------------------------------------------
\frame{\frametitle{Data Dependencies in Serial Algorithm Build Neighborhoods}
	\centering
	\includestandalone[width=0.75\textwidth]{../figures/tikz/sabnDataDependencies}
}

%------------------------------------------------
\frame{\frametitle{Data Dependencies in Serial Algorithm Calculate Edge Lengths}
	\centering
	\includestandalone[width=0.85\textwidth]{../figures/tikz/sacelDataDependencies}
}

%------------------------------------------------
\frame{\frametitle{Data Dependencies in Serial Algorithm Convolve Filter}
	\centering
	\includestandalone[width=0.5\textwidth]{../figures/tikz/sacfDataDependencies}
} 


%================================================
\subsection{Parallel Algorithm}

%------------------------------------------------
\frame{\frametitle{Parallel Alg. 1}

}

%------------------------------------------------
\frame{\frametitle{Parallel Algorithm for Calculating Edge Lengths}
\begin{algorithm}[H]
	\SetAlgoSkip{}
	\DontPrintSemicolon
	\SetCommentSty{small}
	\SetKwFor{For}{for}{:}{}
	\SetKwProg{Func}{Function}{}{}
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

	\only<1>{
	\begin{block}{}%Part (1 of 1)}
		\Input{the set of all points $\bP$, \\
			the set of discovered neighborhoods $\bN$}
		\Output{the set of pre-calculated edge lengths $\bE$, \\
			the minimum edge length of the mesh $\gelm$}

		\bigskip
	\nl	\Func{serialCalculateEdgeLengths($\bP$, $\bN$)}{
	\nl		\For{$\bp_v \in \bP$}{
	\nl			\For{$\bp_i \in \bN_v$}{
					\linespread{1.5}\selectfont
	\nl				$\bE_{\sv{i}} \leftarrow |\bp_i - \bp_v|$\tcc*[r]{This is $\ellstar$}
	\nl				$\gelm \leftarrow \min\left \{\gelm,\,\bE_{\sv{i}}\right \}$\;
				}
			}
		}
	\end{block}
	}
\end{algorithm}
}

%------------------------------------------------
\frame{\frametitle{Parallel Algorithm for Convolving the Filter}
	\vspace*{-8mm}
	\begin{columns}
		\begin{column}[t]{.35\textwidth}
			\begin{block}{}
				{\fontsize{4.2}{4.2}\selectfont
					\begin{algorithm}[H]
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
						\Input{the set of all points $\bP$, \\
							the set of discovered neighborhoods $\bN$, \\
							the set of pre-calculated edge lengths $\bE$, \\
							the minimum edge length of the mesh $\gelm$, \\
							the set of function values $\bF$, \\
							the user-defined number of convolutions $\tau$}
						\Output{the set of one-ring \wmfv{s} $\bF'$}

						\medskip
						\linespread{1.2}\selectfont
					\nl	\Func{serialConvolveFilter($\bP$, $\bN$, $\bE$, $\gelm$, $\bF$, $\tau$)}{
					\nl		\For{$t\leftarrow 1\;\KwTo\;\tau$}{
					\nl			\For{$\bp_v \in \bP$}{
					\nl				\For{$\bp_i \in \bN_v$}{
										\linespread{1.5}\selectfont
					\nl					$\kern-0.5pt\alpha \leftarrow cos^{-1} \kern-6pt\left (\frac{\bE_c^2\,+\,\bE_b^2\,-\,\bE_a^2}{2\,\cdot\,\bE_c\,\cdot\,\bE_b}\right )$\;
										\linespread{1.2}\selectfont
					\nl					$\kern0.00pt\beta \leftarrow (\pi - \alpha)\mathbin{/}2$\;
					\nl					$\kern-1.5ptA \leftarrow \Big(\gelm\,\Big)^2\kern-4pt\cdot\alpha\mathbin{/}2$\;
					\nl					$\kern1.00pt\check{\ell} \leftarrow \big(4\cdot\gelm\cdot\sin(\alpha\mathbin{/}2)\big)\mathbin{/}3\,\alpha$\;
					\nl					$\kern1.00pt\zeta \leftarrow \gelm\mathbin{/}\sin(\beta)$\;
					\nl					\For{$j \in {1,2}$}{\label{algSCFjloop}
					\nl						$\tilde{\ell}_j \leftarrow \zeta\mathbin{/}\bE_j$\;
					\nl						$f'_j \leftarrow f_0\cdot(1 - \tilde{\ell}_j) + f_j\cdot\tilde{\ell}_j$\;
										}
					\nl					$\check{f} \leftarrow f_0\cdot(1 - \check{\ell}) + \big((f'_1 + f'_2)\cdot\check{\ell}\big)\mathbin{/}2$\;
					\nl					$\kern-2.0pt\tilde{f}_v \leftarrow \tilde{f}_v + A\cdot\check{f}$\;
					\nl					$\kern-4.0pt\tilde{A}_v \leftarrow \tilde{A}_v + A$\;
									}
					\nl				$f'_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\;
								}
					\nl		$\bF' \leftarrow \left \{f'_1,\ldots,\,f'_{|\bP|}\right \}$\;
					\nl 	$\bF \leftarrow \bF'$\;
							}
						}
					\end{algorithm}
				}
			\end{block}
		\end{column}
		\begin{column}[t]{.65\textwidth}				
			\only<1>{
				\begin{block}{Part (1 of 3)}
					\begin{algorithm}[H]
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
						\Input{the set of all points $\bP$, \\
							the set of discovered neighborhoods $\bN$, \\
							the set of pre-calculated edge lengths $\bE$, \\
							the minimum edge length of the mesh $\gelm$, \\
							the set of function values $\bF$, \\
							the user-defined number of convolutions $\tau$}
						\Output{the set of one-ring \wmfv{s} $\bF'$}
					\end{algorithm}
				\end{block}
			}\only<2>{
				\begin{block}{Part (2 of 3)}
					\begin{algorithm}[H]
						\SetAlgoLined
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\setcounter{AlgoLine}{0}
					\nl	\Func{serialConvolveFilter($\bP$, $\bN$, $\bE$, $\gelm$, $\bF$, $\tau$)}{
					\nl		\For{$t\leftarrow 1\;\KwTo\;\tau$}{
					\nl			\For{$\bp_v \in \bP$}{
					\nl				\For{$\bp_i \in \bN_v$}{
										\vspace*{1.5\baselineskip}
										\ldots
										\vspace*{1.5\baselineskip}
									}
						\setcounter{AlgoLine}{15}
					\nl				$f'_v \leftarrow \tilde{f}_v\mathbin{/}\tilde{A}_v$\;
								}
					\nl		$\bF' \leftarrow \left \{f'_1,\ldots,\,f'_{|\bP|}\right \}$\;
					\nl 	$\bF \leftarrow \bF'$\;
							}
						}
					\end{algorithm}
				\end{block}
			}\only<3>{
				\begin{block}{Part (3 of 3)}
					{\fontsize{9}{9.5}\selectfont
					\begin{algorithm}[H]
						\SetAlgoLined
						\DontPrintSemicolon
						\SetCommentSty{small}
						\SetKwFor{For}{for}{:}{}
						\SetKwProg{Func}{Function}{}{}
						\SetKwProg{Cont}{}{}{}
						\setcounter{AlgoLine}{7}
						\vspace*{-1\baselineskip}
						\Cont{}{
							\vspace*{-1\baselineskip}
							\Cont{}{
								\vspace*{-1\baselineskip}
								\Cont{}{
									\vspace*{-1\baselineskip}
									\Cont{}{					
										\linespread{1.5}\selectfont
					\nl					$\kern-0.5pt\alpha \leftarrow cos^{-1} \kern-6pt\left (\frac{\bE_c^2\,+\,\bE_b^2\,-\,\bE_a^2}{2\,\cdot\,\bE_c\,\cdot\,\bE_b}\right )$\;
										\linespread{1.2}\selectfont
					\nl					$\kern0.00pt\beta \leftarrow (\pi - \alpha)\mathbin{/}2$\;
					\nl					$\kern-1.5ptA \leftarrow \Big(\gelm\,\Big)^2\kern-4pt\cdot\alpha\mathbin{/}2$\;
					\nl					$\kern1.00pt\check{\ell} \leftarrow \big(4\cdot\gelm\cdot\sin(\alpha\mathbin{/}2)\big)\mathbin{/}3\,\alpha$\;
					\nl					$\kern1.00pt\zeta \leftarrow \gelm\mathbin{/}\sin(\beta)$\;
					\nl					\For{$j \in {1,2}$}{\label{algSCFjloop}
					\nl						$\tilde{\ell}_j \leftarrow \zeta\mathbin{/}\bE_j$\;
					\nl						$f'_j \leftarrow f_0\cdot(1 - \tilde{\ell}_j) + f_j\cdot\tilde{\ell}_j$\;
										}
					\nl					$\check{f} \leftarrow f_0\cdot(1 - \check{\ell}) + \big((f'_1 + f'_2)\cdot\check{\ell}\big)\mathbin{/}2$\;
					\nl					$\kern-2.0pt\tilde{f}_v \leftarrow \tilde{f}_v + A\cdot\check{f}$\;
					\nl					$\kern-4.0pt\tilde{A}_v \leftarrow \tilde{A}_v + A$\;
									}
								}
							}
						}
					\end{algorithm}
					}
				\end{block}
			}
		\end{column}
	\end{columns}
	\begin{tikzpicture}[overlay, remember picture]
		\draw<1>[unirot,ultra thick,rounded corners] (-8mm, 64mm) rectangle (46mm, 50mm);
		\draw<2>[unirot,ultra thick,rounded corners] (-8mm, 50mm) rectangle (46mm, 41mm);
		\draw<2>[unirot,ultra thick,rounded corners] (-8mm, 15mm) rectangle (46mm,  2mm);
		\draw<3>[unirot,ultra thick,rounded corners] (-8mm, 43mm) rectangle (46mm, 14mm);
	\end{tikzpicture}
}




%================================================
%================================================
\section{Experiments \& Evaluation}


%================================================
\subsection{Filter Response On Synthetic Data}

%------------------------------------------------
\frame{\frametitle{Bisected-Square Tessellations}
	\input{../figures/latex/sq2.tex}
}

%------------------------------------------------
\frame{\frametitle{Quadrisected-Square Tessellations}
	\input{../figures/latex/sq4.tex}
}

%------------------------------------------------
\frame{\frametitle{Hexagonal Tessellations}
	\input{../figures/latex/hex.tex}
}

%------------------------------------------------
\frame{\frametitle{Random Triangulated Discs}
	\input{../figures/latex/rdisc.tex}
}


%================================================
\subsection{Filter Response On Acquired Data}

%------------------------------------------------
\frame{\frametitle{The University of Heidelberg Seal}
	\input{../figures/latex/unisiegel.tex}
}

%------------------------------------------------
\frame{\frametitle{A flat surface from ILATO}
	\input{../figures/latex/ILATO.tex}
}

%------------------------------------------------
\frame{\frametitle{The Stanford Bunny}
	\input{../figures/latex/bun.tex}
}




%================================================
\subsection{Convolving with a GPGPU}

%------------------------------------------------
\frame{\frametitle{Evaluation and Analysis of Parallel Algorithms}

\begin{align*}
	\mathit{T_s}(\hat{n}) &= \text{The optimal sequential execution time} \\
	\mathit{T_{\rho}}(\hat{n},\,\rho) &= \text{Parallel runtime}
\end{align*}

which can then be used to define the three essential metrics:

\begin{align*}
	\text{Speedup:}\quad&\mathit{S}(\hat{n},\,\rho) = \frac{\mathit{T_s}(\hat{n})}{\mathit{T_{\rho}}(\hat{n},\,\rho)} \\
	\text{Costs}:\quad&\mathit{C}(\hat{n},\,\rho) =\rho\cdot\mathit{T_{\rho}}(\hat{n},\,\rho) \\
	\text{Efficiency}:\quad&\mathit{E}(\hat{n},\,\rho) = \frac{\mathit{T_s}(\hat{n})}{\mathit{C}(\hat{n},\,\rho)} = \frac{\mathit{S}(\hat{n},\,\rho)}{\rho}
\end{align*}
}

%------------------------------------------------
\frame{\frametitle{Amdahl's law and the Degree of Parallelism}
Also important is the notion of an algorithm's ``degree of parallelism'', which is the maximum number of operations that can be executed in parallel, a principle central to Amdahl's law which is defined as, when given a constant problem size $\hat{n}_{fixed}$, and an algorithm's degree of parallelism $q$,

\begin{equation*}
	\lim_{\rho \to \infty} \mathit{S}(\hat{n}_{fixed},\,\rho) = 1 / q
\end{equation*}

This leads to the conclusion that one can not simply add more processors in order to gain appreciable speedup, but instead that relies heavily on processor counts which grow in relation to problem sizes, and the degree of parallelism, which itself relies on the underlying nature of the serial algorithm and the artful design of the parallel algorithm.
}

%------------------------------------------------
\frame{\frametitle{Compute Times per Experiment for increasing Convolution Counts}
\begin{figure}[ht]
\includegraphics[width=1.0\linewidth,height=1.0\textheight,keepaspectratio]
	{../figures/computeTimesLinespoints.png}
	\caption[Compute Times per Experiment for increasing Convolution Counts]{Compute times per experiment, for increasing numbers of convolutions of \fors{t}, onto acquired and synthetic \tdd{} of varying sizes. Combinations involving the smallest mesh sizes are colored red, the largest mesh sizes in blue, with all others scaled in between. The experiments involving acquired \tdd{} are specially marked with squares for the flat surface mesh, and circles for the university seal.

\vspace*{\baselineskip}
\scriptsize‚Ä† The experiment codes used correspond to: the system, T for the desktop or M for the laptop; the algorithm variant, P for parallel or S for serial; the mesh being processed, BS for bisected-square, HT for hexagonal tessellation, US for university seal, and FS for the flat surface; and finally, the count of points comprising the mesh.}
	\label{fig:computeTimesLP}
\end{figure}
}

%------------------------------------------------
\frame{\frametitle{Compute Times Scatter Plot}
\begin{figure}[ht]
	\includegraphics[width=\linewidth]{../figures/computeTimesScatter.png}
	\caption[Compute Times Scatter Plot]{A plot of the total compute times of each experiment as the area of a circle, given different hardware configurations. Each is then plotted for each combination of mesh size measured in point counts, and the number of convolutions of \Fors{t}. Blue circles indicate the serial variant computed with a \gls{CPU}, and a red circle indicates the parallel variant was computed on a \gls{GPGPU}.

\vspace*{\baselineskip}
\scriptsize‚Ä† See Figure\ref{fig:computeTimesLP} for an explanation of the experiment codes.}
	\label{fig:computeTimesS}
\end{figure}
}

%------------------------------------------------
\frame{\frametitle{Speedup}
\begin{figure}[ht]
	\includegraphics[width=\linewidth]{../figures/speedup.png}
	\caption[Speedup]{A graph of the \gls{speedup} obtained by convolving the parallel variant of \Fors{t} over meshes of different sizes. Lines in blue, increasing in saturation with the size of the mesh, are experiments run using the \gls{GPGPU} of laptop M with 768 \gls{CUDA} cores. Lines in red, increasing in saturation with the size of the mesh, are experiments run using the \gls{GPGPU}  of desktop T with 2,560 \gls{CUDA} cores. The experiments involving acquired \tdd{} are specially marked with squares for the flat surface mesh, and circles for the university seal.

\vspace*{\baselineskip}
\scriptsize‚Ä† See Figure~\ref{fig:computeTimesLP} for an explanation of the experiment codes.}
	\label{fig:speedup}
\end{figure}
}

%------------------------------------------------
\frame{\frametitle{Efficiency}
\begin{figure}[ht]
	\includegraphics[width=\linewidth]{figures/efficiency.png}
	\caption[Efficiency]{A graph of the \gls{efficiency} obtained by convolving the parallel variant of \Fors{t} over meshes of different sizes. Lines in blue, increasing in saturation with the size of the mesh, are experiments run using the \gls{GPGPU} of laptop M with 768 \gls{CUDA} cores. Lines in red, increasing in saturation with the size of the mesh, are experiments run using the \gls{GPGPU} of desktop T with 2,560 \gls{CUDA} cores. The experiments involving acquired \tdd{} are specially marked with squares for the flat surface mesh and circles for the university seal.

\vspace*{\baselineskip}
\scriptsize‚Ä† See Figure~\ref{fig:computeTimesLP} for an explanation of the experiment codes.}
	\label{fig:efficiency}
\end{figure}
}


%================================================
%================================================
\section[Conclusion]{Conclusion \& Outlook}

%------------------------------------------------
\frame{\frametitle{Conclusion}
	\begin{itemize}
		\item item 1
		\item item 1
		\item item 1
		\item item 1
		\item item 1
	\end{itemize}
}

%------------------------------------------------
\frame{\frametitle{Outlook}
	\begin{itemize}
		\item item 1
		\item item 1
		\item item 1
		\item item 1
		\item item 1
	\end{itemize}
}

%------------------------------------------------
\frame{\frametitle{Questions}
	\includegraphics[width=.8\textwidth]{questions}
	\vspace*{-3.3cm}
	\begin{center}
		\begin{LARGE}
			\textbf{Questions}
		\end{LARGE}
	\end{center}
	\vspace*{2cm}
}

\end{document}
